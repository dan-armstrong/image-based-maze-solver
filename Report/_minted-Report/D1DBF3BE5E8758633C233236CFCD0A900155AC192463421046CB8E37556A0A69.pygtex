\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}


\PYG{k}{class} \PYG{n+nc}{Heap}\PYG{p}{:}                                                                     \PYG{c+c1}{\PYGZsh{}MIN HEAP USED AS A PRIORITY QUEUE}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb+bp}{None}\PYG{p}{]}                                                     \PYG{c+c1}{\PYGZsh{}ADD EMPTY ITEM SO INDEXING STARTS AT ONE}

    \PYG{k}{def} \PYG{n+nf}{push}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{item}\PYG{p}{):}                                                       \PYG{c+c1}{\PYGZsh{}ADD ITEM TO HEAP}
        \PYG{k}{try} \PYG{p}{:} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{value}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}                                                  \PYG{c+c1}{\PYGZsh{}MAKE SURE IT IS COMPATIBLE}
        \PYG{k}{except} \PYG{p}{:} \PYG{k}{raise} \PYG{n+ne}{TypeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}New item not compatible with ordering function\PYGZsq{}}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{p}{()]}\PYG{o}{.}\PYG{n}{queue\PYGZus{}index} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{p}{()}                   \PYG{c+c1}{\PYGZsh{}CHANGE INDEX OF ITEM SO IT CAN BE FOUND EASILY}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{bubble\PYGZus{}up}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{p}{())}

    \PYG{k}{def} \PYG{n+nf}{pop}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}                                                              \PYG{c+c1}{\PYGZsh{}REMOVE MIN ITEM}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{p}{()} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{p}{:} \PYG{k}{raise} \PYG{n+ne}{IndexError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Queue is empty \PYGZhy{} cannot pop\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{item} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{queue\PYGZus{}index} \PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{k}{del} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{bubble\PYGZus{}down}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{item}

    \PYG{k}{def} \PYG{n+nf}{update}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{index}\PYG{p}{):}                                                    \PYG{c+c1}{\PYGZsh{}UPDATE THE POSITION OF AN ITEM}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{bubble\PYGZus{}up}\PYG{p}{(}\PYG{n}{index}\PYG{p}{)}                                                   \PYG{c+c1}{\PYGZsh{}SCORE ONLY GOES DOWN SO BUBBLE UP}

    \PYG{k}{def} \PYG{n+nf}{bubble\PYGZus{}up}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{index}\PYG{p}{):}                                                 \PYG{c+c1}{\PYGZsh{}COMPARE ITEM WITH PARENT AND SWAP UNTIL CORRECT}
        \PYG{k}{while} \PYG{n}{index}\PYG{o}{//}\PYG{l+m+mi}{2} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{compare}\PYG{p}{(}\PYG{n}{index}\PYG{o}{//}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{index}\PYG{p}{)} \PYG{p}{:} \PYG{k}{break}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{n}{index}\PYG{p}{,} \PYG{n}{index}\PYG{o}{//}\PYG{l+m+mi}{2}\PYG{p}{)}
            \PYG{n}{index} \PYG{o}{=} \PYG{n}{index}\PYG{o}{//}\PYG{l+m+mi}{2}

    \PYG{k}{def} \PYG{n+nf}{bubble\PYGZus{}down}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{index}\PYG{p}{):}                                               \PYG{c+c1}{\PYGZsh{}COMPARE ITEM WITH CHILDREN AND SWAP UNTIL CORRECT}
        \PYG{k}{while} \PYG{n}{index}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{p}{():}
            \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{compare}\PYG{p}{(}\PYG{n}{index}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{index}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{index}\PYG{p}{):}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{n}{index}\PYG{p}{,} \PYG{n}{index}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
                \PYG{n}{index} \PYG{o}{=} \PYG{n}{index}\PYG{o}{*}\PYG{l+m+mi}{2}
            \PYG{k}{elif} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{compare}\PYG{p}{(}\PYG{n}{index}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{index}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{index}\PYG{p}{):}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{n}{index}\PYG{p}{,} \PYG{n}{index}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
                \PYG{n}{index} \PYG{o}{=} \PYG{n}{index}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{1}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{k}{break}
        \PYG{k}{if} \PYG{n}{index}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZlt{}=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{p}{():}                                            \PYG{c+c1}{\PYGZsh{}IF ONLY HAS ONE CHILD COMPARE WITH THIS}
            \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{compare}\PYG{p}{(}\PYG{n}{index}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{index}\PYG{p}{):}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{n}{index}\PYG{p}{,} \PYG{n}{index}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{value}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{item}\PYG{p}{):}                                                      \PYG{c+c1}{\PYGZsh{}GETS THE VALUE OF AN ITEM}
        \PYG{k}{return} \PYG{n}{item}\PYG{o}{.}\PYG{n}{score}\PYG{p}{()}

    \PYG{k}{def} \PYG{n+nf}{compare}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{n+nb+bp}{None}\PYG{p}{):}                                          \PYG{c+c1}{\PYGZsh{}COMPARES THE VALUE OF 2 OR 3 ITEMS}
        \PYG{k}{try}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{c} \PYG{o}{==} \PYG{n+nb+bp}{None}\PYG{p}{:}
                \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{value}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{n}{a}\PYG{p}{])} \PYG{o}{\PYGZlt{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{value}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{n}{b}\PYG{p}{])}
            \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{value}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{n}{a}\PYG{p}{])} \PYG{o}{\PYGZlt{}=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{value}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{n}{b}\PYG{p}{])} \PYG{o}{\PYGZlt{}=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{value}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{n}{c}\PYG{p}{])}
        \PYG{k}{except}\PYG{p}{:}
            \PYG{k}{raise} \PYG{n+ne}{TypeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Incomparable items in queue\PYGZsq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{swap}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{):}                                                       \PYG{c+c1}{\PYGZsh{}SWAP TWO ITEMS IN THE ARRAY}
        \PYG{n}{temp} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{o}{=} \PYG{n}{temp}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{o}{.}\PYG{n}{queue\PYGZus{}index} \PYG{o}{=} \PYG{n}{a}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{o}{.}\PYG{n}{queue\PYGZus{}index} \PYG{o}{=} \PYG{n}{b}

    \PYG{k}{def} \PYG{n+nf}{length}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}                                                           \PYG{c+c1}{\PYGZsh{}RETURNS LENGTH OF HEAP}
        \PYG{k}{return} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{array}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}                                              \PYG{c+c1}{\PYGZsh{}SUBTRACT ONE FOR EMPTY ITEM AT START}



\PYG{k}{class} \PYG{n+nc}{Hash\PYGZus{}Table}\PYG{p}{:}                                                               \PYG{c+c1}{\PYGZsh{}HASH TABLE USED FOR STORING NODE DATA}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{capacity}\PYG{p}{):}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{capacity} \PYG{o}{=} \PYG{n}{capacity}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{p}{[[]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{capacity}\PYG{p}{)]}                               \PYG{c+c1}{\PYGZsh{}CREATE ARRAY OF SPECIFIC SIZE NEEDED}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{keys} \PYG{o}{=} \PYG{p}{[]}

    \PYG{k}{def} \PYG{n+nf}{insert}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{key}\PYG{p}{,} \PYG{n}{value}\PYG{p}{):}
        \PYG{k}{try} \PYG{p}{:} \PYG{n}{index} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{hash\PYGZus{}function}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}                                   \PYG{c+c1}{\PYGZsh{}TEST THAT KEY IS COMPATIBLE WITH HASHING}
        \PYG{k}{except} \PYG{p}{:} \PYG{k}{raise} \PYG{n+ne}{TypeError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Key incompatible with hash function\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{items} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}
        \PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{False}
        \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{items}\PYG{p}{:}                                                      \PYG{c+c1}{\PYGZsh{}SEE IF ITEM HAS BEEN ADDED BEFORE}
            \PYG{k}{if} \PYG{n}{item}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{n}{key}\PYG{p}{:}
                \PYG{n}{item}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{value}                                                 \PYG{c+c1}{\PYGZsh{}UPDATE VALUE INSTEAD OF ADDING IT AGAIN}
                \PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
                \PYG{k}{break}
        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{found} \PYG{p}{:} \PYG{n}{items}\PYG{o}{.}\PYG{n}{append}\PYG{p}{([}\PYG{n}{key}\PYG{p}{,} \PYG{n}{value}\PYG{p}{])}                               \PYG{c+c1}{\PYGZsh{}ADD NEW VALUES}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{keys}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{search}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{key}\PYG{p}{):}                                                      \PYG{c+c1}{\PYGZsh{}GET ITEM VIA KEY}
        \PYG{n}{index} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{hash\PYGZus{}function}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}
        \PYG{n}{items} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{items}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{item}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{n}{key} \PYG{p}{:} \PYG{k}{return} \PYG{n}{item}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}                                  \PYG{c+c1}{\PYGZsh{}LOOP THROUGH CHAINED ITEMS TO FIND SPECIFIC ONE}
        \PYG{k}{return} \PYG{n+nb+bp}{None}

    \PYG{k}{def} \PYG{n+nf}{hash\PYGZus{}function}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{key}\PYG{p}{):}                                               \PYG{c+c1}{\PYGZsh{}APPLIES HASH FUNCTION TO KEY AND RETURNS OUTPUT}
        \PYG{n}{k} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{key}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{p}{))}                                            \PYG{c+c1}{\PYGZsh{}CONVERT ID TO A NUMBER}
        \PYG{n}{x} \PYG{o}{=} \PYG{n}{k} \PYG{o}{*} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{1}
        \PYG{k}{return} \PYG{n}{math}\PYG{o}{.}\PYG{n}{floor}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{capacity} \PYG{o}{*} \PYG{n}{x}\PYG{p}{)}                                    \PYG{c+c1}{\PYGZsh{}RETURN INTEGER VALUE}

    \PYG{k}{def} \PYG{n+nf}{length}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}                                                           \PYG{c+c1}{\PYGZsh{}RETURN LENGTH OF HASH TABLE}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{capacity}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}setitem\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{key}\PYG{p}{,} \PYG{n}{value}\PYG{p}{):}                                          \PYG{c+c1}{\PYGZsh{}IN\PYGZhy{}BUILT FUNCTIONALITY TO ADD ITEM VIA []}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{key}\PYG{p}{):}                                                 \PYG{c+c1}{\PYGZsh{}IN\PYGZhy{}BUILT FUNCTIONALITY TO FIND ITEM VIA []}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{search}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}
\end{Verbatim}
