point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric())#
  print(points)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(4))#
  print(points)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  print(points)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  print(points)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  print(type(points))#
  min_y <- min(points$y)#
  min_points <- subset(points, y == min_y)#
  print(min_points)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  print(typeof(points))#
  min_y <- min(points$y)#
  min_points <- subset(points, y == min_y)#
  print(min_points)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  print(typeof(points)[1])#
  min_y <- min(points$y)#
  min_points <- subset(points, y == min_y)#
  print(min_points)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  print(typeof(points))#
  min_y <- min(points$y)#
  min_points <- subset(points, y == min_y)#
  print(min_points)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)),#
                       distance=numeric(nrow(positions)))#
  print(typeof(points))#
  min_y <- min(points$y)#
  min_points <- subset(points, y == min_y)#
  print(min_points)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)),#
                       distance=numeric(nrow(positions)))#
  print(typeof(points))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == min_y)#
  print(min_points)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)),#
                       distance=numeric(nrow(positions)))#
  print(typeof(points))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  print(min_points)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)),#
                       distance=numeric(nrow(positions)))#
  print(typeof(points))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  print(bottom_points)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)),#
                       distance=numeric(nrow(positions)))#
  min_x <- min(points$x)#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  bottom_left <- subset(bottom_points, x == min_x)[1]#
  print(bottom_left)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)),#
                       distance=numeric(nrow(positions)))#
  min_x <- min(points$x)#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  bottom_left <- subset(bottom_points, x == min_x)#
  print(bottom_left)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)),#
                       distance=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  bottom_left <- subset(bottom_points, x == min_x)#
  print(bottom_left)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)),#
                       distance=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  bottom_left <- subset(bottom_points, x == min_x)[1]#
  print(bottom_left)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)),#
                       distance=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  bottom_left <- subset(bottom_points, x == min_x)[[1]]#
  print(bottom_left)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)),#
                       distance=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  bottom_left <- subset(bottom_points, x == min_x)[1,]#
  print(bottom_left)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)),#
                       distance=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  print(subset(points, min(y)))#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  bottom_left <- subset(bottom_points, x == min_x)#
#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)),#
                       distance=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  print(subset(points, y==min(y)))#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  bottom_left <- subset(bottom_points, x == min_x)#
#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  start <- bottom_points[which.max(bottom_points$x)]#
  print(start)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  start <- bottom_points[which.min(bottom_points$x)]#
  print(start)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  start <- bottom_points[which.min(bottom_points$x),]#
  print(start)#
}#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
source('merge.r')#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  start_index <- which.min(bottom_points$x)#
  points <- points[-start_index,]#
  merge_sort(points)#
}#
#
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  start_index <- which.min(bottom_points$x)#
  points <- points[-start_index,]#
  merge_sort(points)#
}#
#
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  start_index <- which.min(bottom_points$x)#
  points <- points[-start_index,]#
  print(point[1]$angle)#
  merge_sort(points)#
}#
#
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  start_index <- which.min(bottom_points$x)#
  points <- points[-start_index,]#
  print(points[1]$angle)#
  merge_sort(points)#
}#
#
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  start_index <- which.min(bottom_points$x)#
  points <- points[-start_index,]#
  print(points[1])#
  merge_sort(points)#
}#
#
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  start_index <- which.min(bottom_points$x)#
  points <- points[-start_index,]#
  print(points[1,]$angle)#
  merge_sort(points)#
}#
#
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
merge_numbers <- function(a, b) {#
  pointer_a = 1#
  pointer_b = 1#
  range <- length(a)+length(b)#
  merged <- rep(0, range)#
  for (i in 1:range) {#
    if (pointer_a > length(a)) {#
      merged[i] <- b[pointer_b]#
      pointer_b <- pointer_b + 1#
    }#
    else if (pointer_b > length(b)) {#
      merged[i] <- a[pointer_a]#
      pointer_a <- pointer_a + 1#
    }#
    else if (a[pointer_a] < b[pointer_b]) {#
      merged[i] <- a[pointer_a]#
      pointer_a <- pointer_a + 1#
    }#
    else{#
      merged[i] <- b[pointer_b]#
      pointer_b <- pointer_b + 1#
    }#
  }#
  return(merged)#
}#
merge_points <- function(a, b) {#
  print(a,b)#
  pointer_a = 1#
  pointer_b = 1#
  range <- length(a)+length(b)#
  points <- data.frame(x=numeric(range),#
                       y=numeric(range),#
                       angle=numeric(range))#
  for (i in 1:range) {#
    if (pointer_a > length(a)) {#
      merged[i,] <- b[pointer_b,]#
      pointer_b <- pointer_b + 1#
    }#
    else if (pointer_b > length(b)) {#
      merged[i,] <- a[pointer_a,]#
      pointer_a <- pointer_a + 1#
    }#
    else if (a[pointer_a,]$x == b[pointer_b,]$x) {#
      if (a[pointer_a,]$y < b[pointer_b,]$y) {  #CLOSEST TO START#
        merged[i,] <- a[pointer_a,]#
        pointer_a <- pointer_a + 1#
      }#
      else {#
        merged[i,] <- b[pointer_b,]#
        pointer_b <- pointer_b + 1#
      }#
    }#
    else if (a[pointer_a]$x < b[pointer_b]$x) {#
      merged[i,] <- a[pointer_a,]#
      pointer_a <- pointer_a + 1#
    }#
    else {#
      merged[i,] <- b[pointer_b,]#
      pointer_b <- pointer_b + 1#
    }#
  }#
  return(merged)#
}#
merge_sort <- function(v) {#
  if (length(v) > 1) {#
    m <- ceiling(length(v) / 2)#
    a <- merge_sort(v[1:m])#
    b <- merge_sort(v[(m+1):length(v)])#
    if (typeof(v[1]) == 'S4') {return(merge_points(a,b))}#
    else {return(merge_points(a,b))}#
  }#
  return(v)#
}
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  start_index <- which.min(bottom_points$x)#
  points <- points[-start_index,]#
  print(points[1,]$angle)#
  merge_sort(points)#
}#
#
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
merge_numbers <- function(a, b) {#
  pointer_a = 1#
  pointer_b = 1#
  range <- length(a)+length(b)#
  merged <- rep(0, range)#
  for (i in 1:range) {#
    if (pointer_a > length(a)) {#
      merged[i] <- b[pointer_b]#
      pointer_b <- pointer_b + 1#
    }#
    else if (pointer_b > length(b)) {#
      merged[i] <- a[pointer_a]#
      pointer_a <- pointer_a + 1#
    }#
    else if (a[pointer_a] < b[pointer_b]) {#
      merged[i] <- a[pointer_a]#
      pointer_a <- pointer_a + 1#
    }#
    else{#
      merged[i] <- b[pointer_b]#
      pointer_b <- pointer_b + 1#
    }#
  }#
  return(merged)#
}#
merge_points <- function(a, b) {#
  print(a,b)#
  pointer_a = 1#
  pointer_b = 1#
  range <- length(a)+length(b)#
  points <- data.frame(x=numeric(range),#
                       y=numeric(range),#
                       angle=numeric(range))#
  for (i in 1:range) {#
    if (pointer_a > length(a)) {#
      merged[i,] <- b[pointer_b,]#
      pointer_b <- pointer_b + 1#
    }#
    else if (pointer_b > length(b)) {#
      merged[i,] <- a[pointer_a,]#
      pointer_a <- pointer_a + 1#
    }#
    else if (a[pointer_a,]$x == b[pointer_b,]$x) {#
      if (a[pointer_a,]$y < b[pointer_b,]$y) {  #CLOSEST TO START#
        merged[i,] <- a[pointer_a,]#
        pointer_a <- pointer_a + 1#
      }#
      else {#
        merged[i,] <- b[pointer_b,]#
        pointer_b <- pointer_b + 1#
      }#
    }#
    else if (a[pointer_a]$x < b[pointer_b]$x) {#
      merged[i,] <- a[pointer_a,]#
      pointer_a <- pointer_a + 1#
    }#
    else {#
      merged[i,] <- b[pointer_b,]#
      pointer_b <- pointer_b + 1#
    }#
  }#
  return(merged)#
}#
merge_sort <- function(v) {#
  if (length(v) > 1) {#
    m <- ceiling(length(v) / 2)#
    a <- merge_sort(v[1:m,])#
    b <- merge_sort(v[(m+1):length(v),])#
    if (typeof(v[1]) == 'S4') {return(merge_points(a,b))}#
    else {return(merge_points(a,b))}#
  }#
  return(v)#
}
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
orientation <- function(a, b, c) {#
  value = (c[1]-b[1]) * (b[2]-a[2]) - (b[1]-a[1]) * (c[2]-b[2])#
  if (value == 0) {return(0)}#
  return(ifelse(value<0, -1, 1))#
}#
#
convex_hull <- function(positions) {#
  points <- data.frame(x=positions[,1],#
                       y=positions[,2],#
                       angle=numeric(nrow(positions)))#
  max_y <- max(points$y)#
  bottom_points <- subset(points, y == max_y)#
  min_x <- min(bottom_points$x)#
  start_index <- which.min(bottom_points$x)#
  points <- points[-start_index,]#
  print(points[1,]$angle)#
  merge_sort(points)#
}#
#
point <- setRefClass("point",#
    fields = list(x = "numeric", y = "numeric",#
                  orientation = "numeric", angle = "numeric"))#
#
a <- matrix(c(1,2,3,4,5,6,7,8,9,10,5,10), ncol=2, byrow = TRUE)#
print(a)#
convex_hull(a)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_FILE <- input[2]#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
THRESHOLD_FILE <- 'threshold.csv'#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
main <- function() {#
  update('Loading Greyscale')#
  greyscale_grid <- data.matrix(fread(GREYSCALE_FILE))#
  threshold_grid <- threshold(greyscale_grid)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,2:3]-1, file = WALL_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  write.table(threshold_grid, file = THRESHOLD_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(THRESHOLD_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- 1:t                                                             #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- (t+1):length(hist)#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(1:max(grid), frequency)                         #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- threshold_value(hist)                                                    #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  differences_up <- frequencies_h - c(0,frequencies_h[1:(rows-1)])              #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  differences_down <- frequencies_h - c(frequencies_h[2:rows],0)#
  differences_left <- frequencies_v - c(0,frequencies_v[1:(cols-1)])#
  differences_right <- frequencies_v - c(frequencies_v[2:cols],0)#
  central_dif_h <- merge_sort(ifelse(differences_up > 0, differences_up, 0))#
  central_dif_v <- merge_sort(ifelse(differences_left > 0, differences_left, 0))#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(differences_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(differences_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(differences_left>threshold_v)#
  walls_right <- which(differences_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(differences_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(differences_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])))#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_FILE <- input[2]#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
THRESHOLD_FILE <- 'threshold.csv'#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
RECTILINEAR <- TRUE#
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  greyscale_grid <- data.matrix(fread(GREYSCALE_FILE))#
  threshold_grid <- threshold(greyscale_grid)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,2:3]-1, file = WALL_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  write.table(threshold_grid, file = THRESHOLD_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(THRESHOLD_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- 1:t                                                             #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- (t+1):length(hist)#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(1:max(grid), frequency)                         #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- threshold_value(hist)                                                    #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  differences_up <- frequencies_h - c(0,frequencies_h[1:(rows-1)])              #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  differences_down <- frequencies_h - c(frequencies_h[2:rows],0)#
  differences_left <- frequencies_v - c(0,frequencies_v[1:(cols-1)])#
  differences_right <- frequencies_v - c(frequencies_v[2:cols],0)#
  central_dif_h <- merge_sort(ifelse(differences_up > 0, differences_up, 0))#
  central_dif_v <- merge_sort(ifelse(differences_left > 0, differences_left, 0))#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(differences_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(differences_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(differences_left>threshold_v)#
  walls_right <- which(differences_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(differences_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(differences_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])))#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_FILE <- input[2]#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
THRESHOLD_FILE <- 'threshold.csv'#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
RECTILINEAR <- TRUE#
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  greyscale_grid <- data.matrix(fread(GREYSCALE_FILE))#
  threshold_grid <- threshold(greyscale_grid)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,2:3]-1, file = WALL_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  write.table(threshold_grid, file = THRESHOLD_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(THRESHOLD_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- 1:t                                                             #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- (t+1):length(hist)#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(1:max(grid), frequency)                         #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- threshold_value(hist)                                                    #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  differences_up <- frequencies_h - c(0,frequencies_h[1:(rows-1)])              #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  differences_down <- frequencies_h - c(frequencies_h[2:rows],0)#
  differences_left <- frequencies_v - c(0,frequencies_v[1:(cols-1)])#
  differences_right <- frequencies_v - c(frequencies_v[2:cols],0)#
  central_dif_h <- merge_sort(ifelse(differences_up > 0, differences_up, 0))#
  central_dif_v <- merge_sort(ifelse(differences_left > 0, differences_left, 0))#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(differences_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(differences_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(differences_left>threshold_v)#
  walls_right <- which(differences_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(differences_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(differences_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])))#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
main()#
#
'output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)#
'
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_FILE <- input[2]#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
THRESHOLD_FILE <- 'threshold.csv'#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
RECTILINEAR <- TRUE#
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  greyscale_grid <- data.matrix(fread(GREYSCALE_FILE))#
  threshold_grid <- threshold(greyscale_grid)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,2:3]-1, file = WALL_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  write.table(threshold_grid, file = THRESHOLD_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(THRESHOLD_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- 1:t                                                             #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- (t+1):length(hist)#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(1:max(grid), frequency)                         #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- threshold_value(hist)                                                    #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  differences_up <- frequencies_h - c(0,frequencies_h[1:(rows-1)])              #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  differences_down <- frequencies_h - c(frequencies_h[2:rows],0)#
  differences_left <- frequencies_v - c(0,frequencies_v[1:(cols-1)])#
  differences_right <- frequencies_v - c(frequencies_v[2:cols],0)#
  central_dif_h <- merge_sort(ifelse(differences_up > 0, differences_up, 0))#
  central_dif_v <- merge_sort(ifelse(differences_left > 0, differences_left, 0))#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(differences_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(differences_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(differences_left>threshold_v)#
  walls_right <- which(differences_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(differences_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(differences_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])))#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_FILE <- input[2]#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
RECTILINEAR <- TRUE#
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  greyscale_grid <- data.matrix(fread(GREYSCALE_FILE))#
  threshold_grid <- threshold(greyscale_grid)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,2:3]-1, file = WALL_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  print(threshold_grid)#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- 1:t                                                             #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- (t+1):length(hist)#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(1:max(grid), frequency)                         #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- threshold_value(hist)                                                    #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  differences_up <- frequencies_h - c(0,frequencies_h[1:(rows-1)])              #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  differences_down <- frequencies_h - c(frequencies_h[2:rows],0)#
  differences_left <- frequencies_v - c(0,frequencies_v[1:(cols-1)])#
  differences_right <- frequencies_v - c(frequencies_v[2:cols],0)#
  central_dif_h <- merge_sort(ifelse(differences_up > 0, differences_up, 0))#
  central_dif_v <- merge_sort(ifelse(differences_left > 0, differences_left, 0))#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(differences_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(differences_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(differences_left>threshold_v)#
  walls_right <- which(differences_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(differences_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(differences_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])))#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_FILE <- input[2]#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
RECTILINEAR <- FALSE#
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  greyscale_grid <- data.matrix(fread(GREYSCALE_FILE))#
  threshold_grid <- threshold(greyscale_grid)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,2:3]-1, file = WALL_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  print(threshold_grid)#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- 1:t                                                             #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- (t+1):length(hist)#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(1:max(grid), frequency)                         #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- threshold_value(hist)                                                    #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  differences_up <- frequencies_h - c(0,frequencies_h[1:(rows-1)])              #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  differences_down <- frequencies_h - c(frequencies_h[2:rows],0)#
  differences_left <- frequencies_v - c(0,frequencies_v[1:(cols-1)])#
  differences_right <- frequencies_v - c(frequencies_v[2:cols],0)#
  central_dif_h <- merge_sort(ifelse(differences_up > 0, differences_up, 0))#
  central_dif_v <- merge_sort(ifelse(differences_left > 0, differences_left, 0))#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(differences_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(differences_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(differences_left>threshold_v)#
  walls_right <- which(differences_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(differences_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(differences_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])))#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
if (RECTILINEAR && )
(TRUE && TRUE)
(TRUE && FALSE)
(TRUE & FALSE)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#
setwd(input[1])#
MAZE_CSV <- input[2]#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
MAZE_GRID <- data.matrix(fread(MAZE_CSV))#
#
main <- function() {#
  walls_vector <- mapply(wall_data, col(MAZE_GRID), row(MAZE_GRID))#
  walls <- matrix(walls_vector[!is.na(walls_vector)], byrow = TRUE, ncol=2)#
  file_name <- 'walls.csv'#
  write.table(walls, file = file_name,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(file_name)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
wall_data <- function(x, y) {#
  if (y == 1) {update(paste('Finding walls',round(x/ncol(MAZE_GRID)*100),'%'))}#
  if (MAZE_GRID[y,x] == 1) {#
    return(c(x, y))#
  }#
  return(c(NA, NA))#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
dimensions_x <- length(walls_vertical)-1
a <- 1:10
a[c(2,1)]
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_FILE <- input[2]#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
#GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
#QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
#UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
#RECTILINEAR <- FALSE#
#source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  greyscale_grid <- data.matrix(fread(GREYSCALE_FILE))#
  threshold_grid <- threshold(greyscale_grid)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #R INDEXING AND X BEFORE Y#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
#
R VECTOR OF LENGTH ONE IN HISTOGRAM#
#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), 1)                       #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  central_dif_h <- merge_sort(ifelse(edges_up > 0, edges_up, 0))#
  central_dif_v <- merge_sort(ifelse(edges_left > 0, edges_left, 0))#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])))#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
if (x == END_POINTS[1] && y == END_POINTS[2]) {return(TRUE)}
c(1,2)
c(1,2) == c(1,3)
c(1,2) = c(1,3)
if(c(1,2) == c(1,3)) {print(1)}
all(c(1,2) == c(1,3))
all(c(1,2) == c(1,2))
x <- 1
y <- 2
a <- c(3,4,1,2)
all(c(x,y)==a[1:2])
all(c(x,y)==a[3:4])
if
a
a <- matrix(1:10)
a
a <- matrix(1:10, ncol=2)
a
a[0]
a[0] == 0
a[0] = 0
a[0]
a[0] = 2
a[0]
a[0] == 1
if (a[0] == 1) {print(1)}
if (a[1,0] == 1) {print(1)}
a <- 1:10
a <- c(1,2,3,4,5,4,3,2,1,2,3,2,1,1)
which(a==1)
which(a[:8]==1)
which(a[8,]==1)
which(a[8:]==1)
which(a[1:8]==1)
which(a[1:15]==1)
which(a[1:10]==1)
which(a[1:9]==1)
which(a[1:9]==10)
which(a[1:9]==10)[1]
tail(which(a[1:9]==10),1)
tail(which(a[1:9]==10),1)[1]
tail(which(a[1:9]==5),1)[1]
which(a[1:9]==10) == 0
which(a[1:9]==10) == 1
which(a[1:9]==10) == integer(0)
which(a[1:9]==10)[1]
which(a[1:9]==10)[1] == NA
is.na(which(a[1:9]==10)[1])
is.na(which(a[1:9]==10))
is.integer(which(a[1:9]==10))
nrow(a)
a <- matrix(a)
nrow(a)
ncol(a)
col(a)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1))[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
up_grid <- matrix(mapply(count_up, col(MAZE_GRID), row(MAZE_GRID)), nrow=nrow(MAZE_GRID))#
print(up_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1))[1]#
  if (is.na(prev_wall)) {return(10+y)}#
  return(100+y-prev_wall)#
}#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
up_grid <- matrix(mapply(count_up, col(MAZE_GRID), row(MAZE_GRID)), nrow=nrow(MAZE_GRID))#
print(up_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(10+y)}#
  return(100+y-prev_wall)#
}#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
up_grid <- matrix(mapply(count_up, col(MAZE_GRID), row(MAZE_GRID)), nrow=nrow(MAZE_GRID))#
print(up_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
up_grid <- matrix(mapply(count_up, col(MAZE_GRID), row(MAZE_GRID)), nrow=nrow(MAZE_GRID))#
print(up_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
up_grid <- matrix(mapply(count_up, col(MAZE_GRID), row(MAZE_GRID)), nrow=nrow(MAZE_GRID))#
left_grid <- matrix(mapply(count_left, col(MAZE_GRID), row(MAZE_GRID)), nrow=nrow(MAZE_GRID))#
print(up_grid)#
print(left_grid)
c <- array(1:100, c(10,10,10))
c
c <- array(1:1000, c(10,10,10))
c[1,,]
c <- array(1:8, c(2,2,2))
c
c[1,1,1]
c[1,1,2]
c[1,2,1]
c[2,1,1]
help array
help(array)
c[1,,]
a <- array(1:4)
a
c <- 5:8
array(c(a,c), c(1,2))
array(c(a,c), c(2,4))
a <- 1:4
b <- 5:8
c <- 9:12
d <- 13:16
array(c(a,b,c,d), c(2,2,4))
array(c(a,b,c,d), c(4,2,2))
array(c(a,b,c,d), c(2,2,2))
a <- c(1,2)
b <- a*10
c <- b*10
d <- c*10
array(c(a,b,c,d), c(2,2,2))
g <- array(c(a,b,c,d), c(2,2,2))
g[1,1,]
g[,1,1]
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, col(MAZE_GRID), row(MAZE_GRID)), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width, height))}#
  if (x-width == 0) {return(c(width, height))}#
  if (height < 3) {return(c(0,0)}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width, height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
#
rect_data <- mapply(max_area, col(MAZE_GRID), row(MAZE_GRID))#
rect_grid <- array(rect_data, c(2, ncol(MAZE_GRID), nrow(MAZE_GRID)))#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, col(MAZE_GRID), row(MAZE_GRID)), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width, height))}#
  if (x-width == 0) {return(c(width, height))}#
  if (height < 3) {return(c(0,0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width, height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
#
rect_data <- mapply(max_area, col(MAZE_GRID), row(MAZE_GRID))#
rect_grid <- array(rect_data, c(2, ncol(MAZE_GRID), nrow(MAZE_GRID)))#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
COLS <- cols(MAZE_GRID)#
ROWS <- rows(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=length(ROWS))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width, height))}#
  if (x-width == 0) {return(c(width, height))}#
  if (height < 3) {return(c(0,0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width, height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- array(rect_data, c(2, length(COLS), length(ROWS)))#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=length(ROWS))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width, height))}#
  if (x-width == 0) {return(c(width, height))}#
  if (height < 3) {return(c(0,0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width, height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- array(rect_data, c(2, length(COLS), length(ROWS)))#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=length(ROWS))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width, height))}#
  if (x-width == 0) {return(c(width, height))}#
  if (height < 3) {return(c(0,0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width, height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
#
print(UP_GRID)#
#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- array(rect_data, c(2, length(COLS), length(ROWS)))#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width, height))}#
  if (x-width == 0) {return(c(width, height))}#
  if (height < 3) {return(c(0,0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width, height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
#
print(UP_GRID)#
#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- array(rect_data, c(2, ncol(MAZE_GRID), nrow(MAZE_GRID)))#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width, height))}#
  if (x-width == 0) {return(c(width, height))}#
  if (height < 3) {return(c(0,0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width, height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- array(rect_data, c(2, ncol(MAZE_GRID), nrow(MAZE_GRID)))#
mapply(function(x, y) print(rect_grid[,y,x]), COLS, ROWS)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width, height))}#
  if (x-width == 0) {return(c(width, height))}#
  if (height < 3) {return(c(0,0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width, height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- array(rect_data, c(2, ncol(MAZE_GRID), nrow(MAZE_GRID)))#
mapply(function(y, x) print(rect_grid[,y,x]), COLS, ROWS)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width*height))}#
  if (x-width == 0) {return(c(width*height))}#
  if (height < 3) {return(c(0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width*height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
rect_grid <- array(rect_data, c(2, ncol(MAZE_GRID), nrow(MAZE_GRID)))#
mapply(function(y, x) print(rect_grid[,y,x]), COLS, ROWS)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width*height))}#
  if (x-width == 0) {return(c(width*height))}#
  if (height < 3) {return(c(0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width*height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(rect_grid)#
#rect_grid <- array(rect_data, c(2, ncol(MAZE_GRID), nrow(MAZE_GRID)))#
#mapply(function(y, x) print(rect_grid[,y,x]), COLS, ROWS)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width*height))}#
  if (x-width == 0) {return(c(width*height))}#
  if (height < 3) {return(c(0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width*height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)#
#rect_grid <- array(rect_data, c(2, ncol(MAZE_GRID), nrow(MAZE_GRID)))#
#mapply(function(y, x) print(rect_grid[,y,x]), COLS, ROWS)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width*height))}#
  if (x-width == 0) {return(c(width*height))}#
  if (height < 3) {return(c(0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width*height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)#
#rect_grid <- array(rect_data, c(2, ncol(MAZE_GRID), nrow(MAZE_GRID)))#
#mapply(function(y, x) print(rect_grid[,y,x]), COLS, ROWS)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width,height))}#
  if (x-width == 0) {return(c(width,height))}#
  if (height < 3) {return(c(0,0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width,height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- array(rect_data, c(2, ncol(MAZE_GRID), nrow(MAZE_GRID)))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)#
#rect_grid <- array(rect_data, c(2, ncol(MAZE_GRID), nrow(MAZE_GRID)))#
#mapply(function(y, x) print(rect_grid[,y,x]), COLS, ROWS)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width,height))}#
  if (x-width == 0) {return(c(width,height))}#
  if (height < 3) {return(c(0,0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width,height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- array(rect_data, c(2, ncol(MAZE_GRID), nrow(MAZE_GRID)))#
mapply(function(y, x) print(rect_grid[,y,x]), COLS, ROWS)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width,height))}#
  if (x-width == 0) {return(c(width,height))}#
  if (height < 3) {return(c(0,0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width,height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- array(rect_data, c(2, ncol(MAZE_GRID), nrow(MAZE_GRID)))#
mapply(function(x, y) print(rect_grid[,y,x]), COLS, ROWS)
rect_grid[1,1,1]
rect_grid[2,1,1]
rect_grid[1,1,1]
rect_grid[1,3,2]
rect_grid[2,3,2]
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height, max_width, max_height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(max_width,max_width))}#
  if (x-width == 0) {return(c(width,height))}#
  if (height < 3) {return(c(0,0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width,height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
generate_rectangles#
#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
print(rect_data)#
rect_grid <- array(rect_data, c(2, ncol(MAZE_GRID), nrow(MAZE_GRID)))#
mapply(function(x, y) print(rect_grid[,y,x]), COLS, ROWS)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(c(width, height))}#
  if (x-width == 0) {return(c(width,height))}#
  if (height < 3) {return(c(0,0))}#
  if (UP_GRID[y,x-width+1] < 3) {return(c(width,height))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
generate_rectangles#
#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
print(rect_data)#
rect_grid <- array(rect_data, c(2, ncol(MAZE_GRID), nrow(MAZE_GRID)))#
mapply(function(x, y) print(rect_grid[,y,x]), COLS, ROWS)
'a' + 'b'
c('a', 'b')
join('a', 'b')
paste('a', 'b')
paste('a', 'b', sep='-')
paste('a', 1, sep='-')
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(paste(width,height,sep='-'))}#
  if (x-width == 0) {return(paste(width,height,sep='-'))}#
  if (height < 3) {return(paste(0,0,sep='-'))}#
  if (UP_GRID[y,x-width+1] < 3) {return(paste(width,height,sep='-'))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
rect_grid <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(paste(width,height,sep='-'))}#
  if (x-width == 0) {return(paste(width,height,sep='-'))}#
  if (height < 3) {return(paste(0,0,sep='-'))}#
  if (UP_GRID[y,x-width+1] < 3) {return(paste(width,height,sep='-'))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID)))#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(paste(width,height,sep='-'))}#
  if (x-width == 0) {return(paste(width,height,sep='-'))}#
  if (height < 3) {return(paste(0,0,sep='-'))}#
  if (UP_GRID[y,x-width+1] < 3) {return(paste(width,height,sep='-'))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
count_left <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[y,1:x]==1))[1]#
  if (is.na(prev_wall)) {return(x)}#
  return(x-prev_wall)#
}#
max_area <- function(x, y, width, height) {#
  if (MAZE_GRID[y,x-width+1] == 1) {return(paste(width,height,sep='-'))}#
  if (x-width == 0) {return(paste(width,height,sep='-'))}#
  if (height < 3) {return(paste(0,0,sep='-'))}#
  if (UP_GRID[y,x-width+1] < 3) {return(paste(width,height,sep='-'))}#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x]), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
max_area <- function(x, y, width, height, max_width, max_height) {#
  if (MAZE_GRID[y, x-width+1] == 1) {return(paste(max_width,max_height,sep='-'))}#
  if (x - width == 0) {return(paste(max_width,max_height,sep='-'))}#
  if (height < 3) {return(paste(max_width,max_height,sep='-'))}#
#
  if (width*height > max_width*max_height) {#
    max_width <- width#
    max_height <- height#
  }#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1]))#
  }#
  else {#
    return(max_area(x, y, width+1, height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x], 0, 0), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
max_area <- function(x, y, width, height, max_width, max_height) {#
  if (MAZE_GRID[y, x-width+1] == 1) {return(paste(max_width,max_height,sep='-'))}#
  if (x - width == 0) {return(paste(max_width,max_height,sep='-'))}#
  if (height < 3) {return(paste(max_width,max_height,sep='-'))}#
#
  if (width*height > max_width*max_height) {#
    max_width <- width#
    max_height <- height#
  }#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1], max_width, max_height))#
  }#
  else {#
    return(max_area(x, y, width+1, height, max_width, max_height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x], 0, 0), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
max_area <- function(x, y, width, height, max_width, max_height) {#
  if (MAZE_GRID[y, x-width+1] == 1) {return(paste(max_width,max_height,sep='-'))}#
  if (x - width < 3) {return(paste(max_width,max_height,sep='-'))}#
  if (height < 3) {return(paste(max_width,max_height,sep='-'))}#
#
  if (width*height > max_width*max_height) {#
    max_width <- width#
    max_height <- height#
  }#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1], max_width, max_height))#
  }#
  else {#
    return(max_area(x, y, width+1, height, max_width, max_height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x], 0, 0), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
max_area <- function(x, y, width, height, max_width, max_height) {#
  if (MAZE_GRID[y, x-width+1] == 1) {return(paste(max_width,max_height,sep='-'))}#
  if (x - width < 2) {return(paste(max_width,max_height,sep='-'))}#
  if (height < 3) {return(paste(max_width,max_height,sep='-'))}#
#
  if (width*height > max_width*max_height) {#
    max_width <- width#
    max_height <- height#
  }#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1], max_width, max_height))#
  }#
  else {#
    return(max_area(x, y, width+1, height, max_width, max_height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x], 0, 0), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
max_area <- function(x, y, width, height, max_width, max_height) {#
  if (MAZE_GRID[y, x-width+1] == 1) {return(paste(max_width,max_height,sep='-'))}#
  if (x - width == 0) {return(paste(max_width,max_height,sep='-'))}#
  if (height < 3) {return(paste(max_width,max_height,sep='-'))}#
#
  if (width*height > max_width*max_height) {#
    max_width <- width#
    max_height <- height#
  }#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1], max_width, max_height))#
  }#
  else {#
    return(max_area(x, y, width+1, height, max_width, max_height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x], 0, 0), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
max_area <- function(x, y, width, height, max_width, max_height) {#
  print(x, y, width, height, max_width, max_height)#
  if (MAZE_GRID[y, x-width+1] == 1) {return(paste(max_width,max_height,sep='-'))}#
  if (x - width == 0) {return(paste(max_width,max_height,sep='-'))}#
  if (height < 3) {return(paste(max_width,max_height,sep='-'))}#
#
  if (width*height > max_width*max_height) {#
    max_width <- width#
    max_height <- height#
  }#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1], max_width, max_height))#
  }#
  else {#
    return(max_area(x, y, width+1, height, max_width, max_height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x], 0, 0), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
max_area <- function(x, y, width, height, max_width, max_height) {#
  print(c(x, y, width, height, max_width, max_height))#
  if (MAZE_GRID[y, x-width+1] == 1) {return(paste(max_width,max_height,sep='-'))}#
  if (x - width == 0) {return(paste(max_width,max_height,sep='-'))}#
  if (height < 3) {return(paste(max_width,max_height,sep='-'))}#
#
  if (width*height > max_width*max_height) {#
    max_width <- width#
    max_height <- height#
  }#
#
  if (UP_GRID[y,x-width+1] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width+1], max_width, max_height))#
  }#
  else {#
    return(max_area(x, y, width+1, height, max_width, max_height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x], 0, 0), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
max_area <- function(x, y, width, height, max_width, max_height) {#
  print(c(x, y, width, height, max_width, max_height))#
  if (MAZE_GRID[y, x-width+1] == 1) {return(paste(max_width,max_height,sep='-'))}#
  if (x - width == 0) {return(paste(max_width,max_height,sep='-'))}#
  if (height < 3) {return(paste(max_width,max_height,sep='-'))}#
#
  if (width*height > max_width*max_height) {#
    max_width <- width#
    max_height <- height#
  }#
#
  if (UP_GRID[y,x-width] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width], max_width, max_height))#
  }#
  else {#
    return(max_area(x, y, width+1, height, max_width, max_height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x], 0, 0), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
max_area <- function(x, y, width, height, max_width, max_height) {#
  print(c(x, y, width, height, max_width, max_height))#
  if (MAZE_GRID[y, x-width+1] == 1) {return(paste(max_width,max_height,sep='-'))}#
  if (x - width == 0) {return(paste(max_width,max_height,sep='-'))}#
  if (height < 3) {return(paste(max_width,max_height,sep='-'))}#
#
  if (width*height > max_width*max_height) {#
    max_width <- width#
    max_height <- height#
  }#
#
  if (UP_GRID[y,x-width] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width], max_width, max_height))#
  }#
  else {#
    return(max_area(x, y, width+1, height, max_width, max_height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x], 0, 0), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
print(MAZE_GRID)#
#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
max_area <- function(x, y, width, height, max_width, max_height) {#
  if (MAZE_GRID[y, x-width+1] == 1) {return(paste(max_width,max_height,sep='-'))}#
  if (x - width == 0) {return(paste(max_width,max_height,sep='-'))}#
  if (height < 3) {return(paste(max_width,max_height,sep='-'))}#
#
  if (width*height > max_width*max_height && width >= 3) {#
    max_width <- width#
    max_height <- height#
  }#
#
  if (UP_GRID[y,x-width] < height) {#
    return(max_area(x, y, width+1, UP_GRID[y,x-width], max_width, max_height))#
  }#
  else {#
    return(max_area(x, y, width+1, height, max_width, max_height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x], 0, 0), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- matrix(c(0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0), nrow=4)#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
#
UP_GRID <- matrix(mapply(count_up, COLS, ROWS), nrow=nrow(MAZE_GRID))#
max_area <- function(x, y, width, height, max_width, max_height) {#
  if (MAZE_GRID[y, x-width+1] == 1) {return(paste(max_width,max_height,sep='-'))}#
  if (x - width == 0) {return(paste(max_width,max_height,sep='-'))}#
  if (height < 3) {return(paste(max_width,max_height,sep='-'))}#
#
  if (width*height > max_width*max_height && width >= 3) {#
    max_width <- width#
    max_height <- height#
  }#
#
  if (count_up(x-width, y) < height) {#
    return(max_area(x, y, width+1, count_up(x-width, y), max_width, max_height))#
  }#
  else {#
    return(max_area(x, y, width+1, height, max_width, max_height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x], 0, 0), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)
library("data.table")#
#input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#setwd(input[1])#
#MAZE_GRID <- data.matrix(fread(input[2]))#
#QUIT_FILE <- input[3]#
#UPDATE_FILE <- input[4]#
#
MAZE_GRID <- data.matrix(fread('maze.csv'))#
COLS <- col(MAZE_GRID)#
ROWS <- row(MAZE_GRID)#
count_up <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(0)}#
  prev_wall <- tail(which(MAZE_GRID[1:y,x]==1),1)[1]#
  if (is.na(prev_wall)) {return(y)}#
  return(y-prev_wall)#
}#
max_area <- function(x, y, width, height, max_width, max_height) {#
  if (MAZE_GRID[y, x-width+1] == 1) {return(paste(max_width,max_height,sep='-'))}#
  if (x - width == 0) {return(paste(max_width,max_height,sep='-'))}#
  if (height < 3) {return(paste(max_width,max_height,sep='-'))}#
#
  if (width*height > max_width*max_height && width >= 3) {#
    max_width <- width#
    max_height <- height#
  }#
#
  if (count_up(x-width, y) < height) {#
    return(max_area(x, y, width+1, count_up(x-width, y), max_width, max_height))#
  }#
  else {#
    return(max_area(x, y, width+1, height, max_width, max_height))#
  }#
}#
rect_data <- mapply(function(x, y) max_area(x, y, 1, UP_GRID[y,x], 0, 0), COLS, ROWS)#
rect_grid <- matrix(rect_data, nrow=nrow(MAZE_GRID))#
print(MAZE_GRID)#
print(UP_GRID)#
print(rect_grid)
if (all(c(x, y) == END_POINTS[3:4])) {return(TRUE)}
all(1,2) == c(1,23)
all(c(1,2) == c(1,23))
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#input <- strsplit('/Users/danarmstrong/Desktop/Coursework maze.csv quit.txt update.txt false 2 1 126 95 rect.csv', ' ')[[1]]#
setwd(input[1])#
MAZE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
END_POINTS <- as.integer(input[6:9])#
if (!RECTILINEAR) {#
  RECT_DATA <- data.matrix(fread(input[10]))#
  RECT_GRID <- matrix(TRUE, nrow=nrow(MAZE_GRID), ncol=ncol(MAZE_GRID))#
  RECT_GRID[(RECT_DATA[,2]+1):(RECT_DATA[,4]-1),#
            (RECT_DATA[,1]+1):(RECT_DATA[,3]-1)] <- FALSE#
}#
main <- function() {#
  nodes_vector <- mapply(node_data, col(MAZE_GRID), row(MAZE_GRID))#
  nodes <- matrix(nodes_vector[!is.na(nodes_vector)], byrow = TRUE, ncol=4)#
  file_name <- 'nodes.csv'#
  write.table(nodes-1, file = file_name,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(file_name)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
valid_node <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(FALSE)}#
  if (all(c(x, y) == END_POINTS[1:2])) {return(TRUE)}#
  if (all(c(x, y) == END_POINTS[3:4])) {return(TRUE)}#
#
  if (RECTILINEAR) {#
    nbrs_h <- 2 - MAZE_GRID[y,x-1] - MAZE_GRID[y,x+1]#
    nbrs_v <- 2 - MAZE_GRID[y-1,x] - MAZE_GRID[y+1,x]#
    if (nbrs_h + nbrs_v > 2) {return(TRUE)}#
    if (nbrs_h == 1 && nbrs_v == 1) {return(TRUE)}#
    return(FALSE)#
  }#
#
  else {#
    return(RECT_GRID[y,x])#
}#
nbr_left <- function(x, y) {#
  if (x == 1) {return(0)}#
  if (MAZE_GRID[y,(x-1)] == 1) {return(0)}#
  pos <- tail(which(MAZE_GRID[y,1:(x-1)] == 1), 1)#
  return(pos)#
}#
nbr_up <- function(x, y) {#
  if (y == 1) {return(0)}#
  if (MAZE_GRID[(y-1),x] == 1) {return(0)}#
  pos <- tail(which(MAZE_GRID[1:(y-1),x] == 1), 1)#
  return(pos)#
}#
node_data <- function(x, y) {#
  if (y == 1) {update(paste('Finding nodes',round(x/ncol(MAZE_GRID)*100),'%'))}#
  if (valid_node(x, y)) {#
    return(c(x, y, nbr_left(x, y), nbr_up(x, y)))#
  }#
  return(c(NA, NA, NA, NA))#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
}
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#input <- strsplit('/Users/danarmstrong/Desktop/Coursework maze.csv quit.txt update.txt false 2 1 126 95 rect.csv', ' ')[[1]]#
setwd(input[1])#
MAZE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
END_POINTS <- as.integer(input[6:9])#
if (!RECTILINEAR) {#
  RECT_DATA <- data.matrix(fread(input[10]))#
  RECT_GRID <- matrix(TRUE, nrow=nrow(MAZE_GRID), ncol=ncol(MAZE_GRID))#
  RECT_GRID[(RECT_DATA[,2]+1):(RECT_DATA[,4]-1),#
            (RECT_DATA[,1]+1):(RECT_DATA[,3]-1)] <- FALSE#
}#
main <- function() {#
  nodes_vector <- mapply(node_data, col(MAZE_GRID), row(MAZE_GRID))#
  nodes <- matrix(nodes_vector[!is.na(nodes_vector)], byrow = TRUE, ncol=4)#
  file_name <- 'nodes.csv'#
  write.table(nodes-1, file = file_name,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(file_name)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
valid_node <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(FALSE)}#
  if (all(c(x, y) == END_POINTS[1:2])) {return(TRUE)}#
  if (all(c(x, y) == END_POINTS[3:4])) {return(TRUE)}#
#
  if (RECTILINEAR) {#
    nbrs_h <- 2 - MAZE_GRID[y,x-1] - MAZE_GRID[y,x+1]#
    nbrs_v <- 2 - MAZE_GRID[y-1,x] - MAZE_GRID[y+1,x]#
    if (nbrs_h + nbrs_v > 2) {return(TRUE)}#
    if (nbrs_h == 1 && nbrs_v == 1) {return(TRUE)}#
    return(FALSE)#
  }#
#
  else {#
    return(RECT_GRID[y,x])#
}#
nbr_left <- function(x, y) {#
  if (x == 1) {return(0)}#
  if (MAZE_GRID[y,(x-1)] == 1) {return(0)}#
  pos <- tail(which(MAZE_GRID[y,1:(x-1)] == 1), 1)#
  return(pos)#
}#
nbr_up <- function(x, y) {#
  if (y == 1) {return(0)}#
  if (MAZE_GRID[(y-1),x] == 1) {return(0)}#
  pos <- tail(which(MAZE_GRID[1:(y-1),x] == 1), 1)#
  return(pos)#
}#
node_data <- function(x, y) {#
  if (y == 1) {update(paste('Finding nodes',round(x/ncol(MAZE_GRID)*100),'%'))}#
  if (valid_node(x, y)) {#
    return(c(x, y, nbr_left(x, y), nbr_up(x, y)))#
  }#
  return(c(NA, NA, NA, NA))#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#input <- strsplit('/Users/danarmstrong/Desktop/Coursework maze.csv quit.txt update.txt True 2 1 126 95 rect.csv', ' ')[[1]]#
setwd(input[1])#
MAZE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
END_POINTS <- as.integer(input[6:9])#
if (!RECTILINEAR) {#
  RECT_DATA <- data.matrix(fread(input[10]))#
  RECT_GRID <- matrix(TRUE, nrow=nrow(MAZE_GRID), ncol=ncol(MAZE_GRID))#
  RECT_GRID[(RECT_DATA[,2]+1):(RECT_DATA[,4]-1),#
            (RECT_DATA[,1]+1):(RECT_DATA[,3]-1)] <- FALSE#
}#
main <- function() {#
  nodes_vector <- mapply(node_data, col(MAZE_GRID), row(MAZE_GRID))#
  nodes <- matrix(nodes_vector[!is.na(nodes_vector)], byrow = TRUE, ncol=4)#
  file_name <- 'nodes.csv'#
  write.table(nodes-1, file = file_name,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(file_name)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
valid_node <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(FALSE)}#
  if (all(c(x, y) == END_POINTS[1:2])) {return(TRUE)}#
  if (all(c(x, y) == END_POINTS[3:4])) {return(TRUE)}#
#
  if (RECTILINEAR) {#
    nbrs_h <- 2 - MAZE_GRID[y,x-1] - MAZE_GRID[y,x+1]#
    nbrs_v <- 2 - MAZE_GRID[y-1,x] - MAZE_GRID[y+1,x]#
    if (nbrs_h + nbrs_v > 2) {return(TRUE)}#
    if (nbrs_h == 1 && nbrs_v == 1) {return(TRUE)}#
    return(FALSE)#
  }#
#
  else {#
    return(RECT_GRID[y,x])#
  }#
}#
nbr_left <- function(x, y) {#
  if (x == 1) {return(0)}#
  if (MAZE_GRID[y, x-1] == 1) {return(0)}#
  valid_in_row <- sapply(1:(x-1), function(x) valid_node(x, y))#
  pos <- tail(which(valid_in_row), 1)[1]#
  if (is.na(pos)) {return(0)}#
  return(pos)#
}#
nbr_up <- function(x, y) {#
  if (y == 1) {return(0)}#
  if (MAZE_GRID[y-1, x] == 1) {return(0)}#
  valid_in_col <- sapply(1:(y-1), function(y) valid_node(x, y))#
  pos <- tail(which(valid_in_col), 1)[1]#
  if (is.na(pos)) {return(0)}#
  return(pos)#
}#
node_data <- function(x, y) {#
  if (y == 1) {update(paste('Finding nodes',round(x/ncol(MAZE_GRID)*100),'%'))}#
  if (valid_node(x, y)) {#
    return(c(x, y, nbr_left(x, y), nbr_up(x, y)))#
  }#
  return(c(NA, NA, NA, NA))#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#input <- strsplit('/Users/danarmstrong/Desktop/Coursework maze.csv quit.txt update.txt True 2 1 126 95 rect.csv', ' ')[[1]]#
setwd(input[1])#
MAZE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
END_POINTS <- as.integer(input[6:9])#
if (!RECTILINEAR) {#
  RECT_DATA <- data.matrix(fread(input[10]))#
  RECT_GRID <- matrix(TRUE, nrow=nrow(MAZE_GRID), ncol=ncol(MAZE_GRID))#
  RECT_GRID[(RECT_DATA[,2]+1):(RECT_DATA[,4]-1),#
            (RECT_DATA[,1]+1):(RECT_DATA[,3]-1)] <- FALSE#
}#
main <- function() {#
  nodes_vector <- mapply(node_data, col(MAZE_GRID), row(MAZE_GRID))#
  nodes <- matrix(nodes_vector[!is.na(nodes_vector)], byrow = TRUE, ncol=4)#
  file_name <- 'nodes.csv'#
  write.table(nodes-1, file = file_name,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(file_name)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
valid_node <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(FALSE)}#
  if (all(c(x, y) == END_POINTS[1:2])) {return(TRUE)}#
  if (all(c(x, y) == END_POINTS[3:4])) {return(TRUE)}#
#
  if (RECTILINEAR) {#
    nbrs_h <- 2 - MAZE_GRID[y,x-1] - MAZE_GRID[y,x+1]#
    nbrs_v <- 2 - MAZE_GRID[y-1,x] - MAZE_GRID[y+1,x]#
    if (nbrs_h + nbrs_v > 2) {return(TRUE)}#
    if (nbrs_h == 1 && nbrs_v == 1) {return(TRUE)}#
    return(FALSE)#
  }#
#
  else {#
    return(RECT_GRID[y,x])#
  }#
}#
valid_nbr <- function(x, y, prev_x, prev_y) {#
  if (valid_node(x, y)) {return(TRUE)}#
  if (MAZE_GRID[prev_x, prev_y] == 1 && prev_x > 0 && prev_y > 0) {return(TRUE)}#
  return(FALSE)#
}#
nbr_left <- function(x, y) {#
  if (x == 1) {return(0)}#
  if (MAZE_GRID[y, x-1] == 1) {return(0)}#
  valid_in_row <- sapply(1:(x-1), function(x) valid_nbr(x, y, x-1, y))#
  pos <- tail(which(valid_in_row), 1)[1]#
  if (is.na(pos)) {return(0)}#
  if (valid_node(x, pos)) {return(pos)}#
  return(0)#
}#
nbr_up <- function(x, y) {#
  if (y == 1) {return(0)}#
  if (MAZE_GRID[y-1, x] == 1) {return(0)}#
  valid_in_col <- sapply(1:(y-1), function(y) valid_nbr(x, y, x, y-1))#
  pos <- tail(which(valid_in_col), 1)[1]#
  if (is.na(pos)) {return(0)}#
  if (valid_node(pos, x)) {return(pos)}#
  return(0)#
}#
node_data <- function(x, y) {#
  if (y == 1) {update(paste('Finding nodes',round(x/ncol(MAZE_GRID)*100),'%'))}#
  if (valid_node(x, y)) {#
    return(c(x, y, nbr_left(x, y), nbr_up(x, y)))#
  }#
  return(c(NA, NA, NA, NA))#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#input <- strsplit('/Users/danarmstrong/Desktop/Coursework maze.csv quit.txt update.txt True 2 1 10 10 rect.csv', ' ')[[1]]#
setwd(input[1])#
MAZE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
END_POINTS <- as.integer(input[6:9])#
if (!RECTILINEAR) {#
  RECT_DATA <- data.matrix(fread(input[10]))#
  RECT_GRID <- matrix(TRUE, nrow=nrow(MAZE_GRID), ncol=ncol(MAZE_GRID))#
  RECT_GRID[(RECT_DATA[,2]+1):(RECT_DATA[,4]-1),#
            (RECT_DATA[,1]+1):(RECT_DATA[,3]-1)] <- FALSE#
}#
main <- function() {#
  nodes_vector <- mapply(node_data, col(MAZE_GRID), row(MAZE_GRID))#
  nodes <- matrix(nodes_vector[!is.na(nodes_vector)], byrow = TRUE, ncol=4)#
  file_name <- 'nodes.csv'#
  write.table(nodes-1, file = file_name,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(file_name)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
valid_node <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(FALSE)}#
  if (all(c(x, y) == END_POINTS[1:2])) {return(TRUE)}#
  if (all(c(x, y) == END_POINTS[3:4])) {return(TRUE)}#
#
  if (RECTILINEAR) {#
    nbrs_h <- 2#
    nbrs_v <- 2#
    if (x > 1) {nbrs_h <- nbrs_h - MAZE_GRID[y,x-1]}#
    if (y > 1) {nbrs_v <- nbrs_v - MAZE_GRID[y-1,x]}#
    if (x < ncol(MAZE_GRID)) {nbrs_h <- nbrs_h - MAZE_GRID[y,x+1]}#
    if (y < nrow(MAZE_GRID)) {nbrs_v <- nbrs_v - MAZE_GRID[y+1,x]}#
    if (nbrs_h + nbrs_v > 2) {return(TRUE)}#
    if (nbrs_h == 1 && nbrs_v == 1) {return(TRUE)}#
    return(FALSE)#
  }#
#
  else {#
    return(RECT_GRID[y, x])#
  }#
}#
valid_nbr <- function(x, y, prev_x, prev_y) {#
  if (valid_node(x, y)) {return(TRUE)}#
  if (MAZE_GRID[prev_x, prev_y] == 1 && prev_x > 0 && prev_y > 0) {return(TRUE)}#
  return(FALSE)#
}#
nbr_left <- function(x, y) {#
  if (x == 1) {return(0)}#
  if (MAZE_GRID[y, x-1] == 1) {return(0)}#
  valid_in_row <- sapply(1:(i-1), function(i) valid_nbr(i, y, i-1, y))#
  pos <- tail(which(valid_in_row), 1)[1]#
  if (is.na(pos)) {return(0)}#
  if (valid_node(x, pos)) {return(pos)}#
  return(0)#
}#
nbr_up <- function(x, y) {#
  if (y == 1) {return(0)}#
  if (MAZE_GRID[y-1, x] == 1) {return(0)}#
  valid_in_col <- sapply(1:(i-1), function(y) valid_nbr(x, i, x, i-1))#
  pos <- tail(which(valid_in_col), 1)[1]#
  if (is.na(pos)) {return(0)}#
  if (valid_node(pos, x)) {return(pos)}#
  return(0)#
}#
node_data <- function(x, y) {#
  if (y == 1) {update(paste('Finding nodes',round(x/ncol(MAZE_GRID)*100),'%'))}#
  if (valid_node(x, y)) {#
    return(c(x, y, nbr_left(x, y), nbr_up(x, y)))#
  }#
  return(c(NA, NA, NA, NA))#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
#input <- strsplit('/Users/danarmstrong/Desktop/Coursework maze.csv quit.txt update.txt True 2 1 10 10 rect.csv', ' ')[[1]]#
setwd(input[1])#
MAZE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
END_POINTS <- as.integer(input[6:9])#
if (!RECTILINEAR) {#
  RECT_DATA <- data.matrix(fread(input[10]))#
  RECT_GRID <- matrix(TRUE, nrow=nrow(MAZE_GRID), ncol=ncol(MAZE_GRID))#
  RECT_GRID[(RECT_DATA[,2]+1):(RECT_DATA[,4]-1),#
            (RECT_DATA[,1]+1):(RECT_DATA[,3]-1)] <- FALSE#
}#
main <- function() {#
  nodes_vector <- mapply(node_data, col(MAZE_GRID), row(MAZE_GRID))#
  nodes <- matrix(nodes_vector[!is.na(nodes_vector)], byrow = TRUE, ncol=4)#
  file_name <- 'nodes.csv'#
  write.table(nodes-1, file = file_name,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(file_name)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
valid_node <- function(x, y) {#
  if (MAZE_GRID[y,x] == 1) {return(FALSE)}#
  if (all(c(x, y) == END_POINTS[1:2])) {return(TRUE)}#
  if (all(c(x, y) == END_POINTS[3:4])) {return(TRUE)}#
#
  if (RECTILINEAR) {#
    nbrs_h <- 2#
    nbrs_v <- 2#
    if (x > 1) {nbrs_h <- nbrs_h - MAZE_GRID[y,x-1]}#
    if (y > 1) {nbrs_v <- nbrs_v - MAZE_GRID[y-1,x]}#
    if (x < ncol(MAZE_GRID)) {nbrs_h <- nbrs_h - MAZE_GRID[y,x+1]}#
    if (y < nrow(MAZE_GRID)) {nbrs_v <- nbrs_v - MAZE_GRID[y+1,x]}#
    if (nbrs_h + nbrs_v > 2) {return(TRUE)}#
    if (nbrs_h == 1 && nbrs_v == 1) {return(TRUE)}#
    return(FALSE)#
  }#
#
  else {#
    return(RECT_GRID[y, x])#
  }#
}#
valid_nbr <- function(x, y, prev_x, prev_y) {#
  if (valid_node(x, y)) {return(TRUE)}#
  if (MAZE_GRID[prev_x, prev_y] == 1 && prev_x > 0 && prev_y > 0) {return(TRUE)}#
  return(FALSE)#
}#
nbr_left <- function(x, y) {#
  if (x == 1) {return(0)}#
  if (MAZE_GRID[y, x-1] == 1) {return(0)}#
  valid_in_row <- sapply(1:(x-1), function(pos) valid_nbr(pos, y, pos-1, y))#
  pos <- tail(which(valid_in_row), 1)[1]#
  if (is.na(pos)) {return(0)}#
  if (valid_node(x, pos)) {return(pos)}#
  return(0)#
}#
nbr_up <- function(x, y) {#
  if (y == 1) {return(0)}#
  if (MAZE_GRID[y-1, x] == 1) {return(0)}#
  valid_in_col <- sapply(1:(y-1), function(pos) valid_nbr(x, pos, x, pos-1))#
  pos <- tail(which(valid_in_col), 1)[1]#
  if (is.na(pos)) {return(0)}#
  if (valid_node(pos, x)) {return(pos)}#
  return(0)#
}#
node_data <- function(x, y) {#
  if (y == 1) {update(paste('Finding nodes',round(x/ncol(MAZE_GRID)*100),'%'))}#
  if (valid_node(x, y)) {#
    return(c(x, y, nbr_left(x, y), nbr_up(x, y)))#
  }#
  return(c(NA, NA, NA, NA))#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
library("data.table")#
source('merge.r')#
create_rect_grid <- function(maze_grid, quit_file, update_file) {#
  rect_grid <- matrix(0, nrow=nrow(maze_grid), ncol=ncol(maze_grid))#
#
  update <- function(text) {#
    check_quit()#
    f <- file(update_file)#
    writeLines(c(text), f)#
    close(f)#
  }#
#
  check_quit <- function() {#
    status <- readChar(quit_file, file.info(quit_file)$size)#
    if (status == 'q') {stop('quit')}#
  }#
#
  height_above <- function(x, y) {#
    if (y == 1) {update(paste('Finding free space',round(x/ncol(maze_grid)*100),'%'))}#
    pos <- tail(which(maze_grid[1:y, x] == 1), 1)[1]#
    if (is.na(pos)) {return(y)}#
    return(y - pos)#
  }#
#
  height_grid <- matrix(mapply(height_above, col(maze_grid), row(maze_grid)), nrow=nrow(maze_grid))#
#
  max_area <- function(x, y) {#
    if (y == 1) {update(paste('Calculating area',round(x/ncol(maze_grid)*100),'%'))}#
    width <- 1#
    height <- height_grid[y, x]#
    max_width <- 0#
    max_height <- 0#
    while (height >= 3 && x - (width-1) >= 1) {#
      if (height_grid[y, x-(width-1)] < height) {#
        height <- height_grid[y, x-(width-1)]#
      }#
      if (width*height > max_width*max_height && width >= 3 && height >= 3) {#
        max_width <- width#
        max_height <- height#
      }#
      width <- width + 1#
    }#
    return(paste(max_width, max_height, sep='-'))#
  }#
#
  area_grid <- matrix(mapply(max_area, col(maze_grid), row(maze_grid)), nrow=nrow(maze_grid))#
#
  create_vector <- function(x, y) {#
    data <- as.integer(strsplit(area_grid[y, x], '-')[[1]])#
    if (data[1]*data[2] > 0) {#
      return(paste(x, y, data[1], data[2], sep='-'))#
    }#
  }#
  area_vector <- mapply(create_vector, col(maze_grid), row(maze_grid))#
  area_vector <- merge_sort(area_vector, TRUE)#
#
  expand_area <- function(data, grid) {#
    x <- data[1]#
    y <- data[2]#
    width <- data[3]#
    height <- data[4]#
    row_clear = FALSE#
    col_clear = FALSE#
#
    while (width >= 3 && height >= 3 && !row_clear && !col_clear) {#
      if (!row_clear) {#
        if (all(grid[y, (x-(width-1)):x] == 0)) {row_clear = TRUE}#
        else {width <- width - 1}#
      }#
      if (!col_clear) {#
        if (all(grid[(y-(height-1)):y, x] == 0)) {col_clear = TRUE}#
        else {height <- height - 1}#
      }#
    }#
    if (width >= 3 && height >= 3) {#
      grid[(y-(height-1)), (x-(width-1)):x] <- 1#
      grid[y, (x-(width-1)):x] <- 1#
      grid[(y-(height-1)+1):(y-1), x-(width-1)] <- 1#
      grid[(y-(height-1)+1):(y-1), x] <- 1#
      grid[(y-(height-1)+1):(y-1), (x-(width-1)+1):(x-1)] <- 2#
    }#
    return(grid)#
  }#
#
  for (row in area_vector) {#
    area_data <- as.integer(strsplit(row, '-')[[1]])#
    if (area_data[3] * area_data[4] == 0) {break}#
    rect_grid <- expand_area(area_data, rect_grid)#
  }#
  return(rect_grid)#
}
library("data.table")#
source('merge.r')#
create_rect_grid <- function(maze_grid, quit_file, update_file) {#
  rect_grid <- matrix(0, nrow=nrow(maze_grid), ncol=ncol(maze_grid))#
#
  update <- function(text) {#
    check_quit()#
    f <- file(update_file)#
    writeLines(c(text), f)#
    close(f)#
  }#
#
  check_quit <- function() {#
    status <- readChar(quit_file, file.info(quit_file)$size)#
    if (status == 'q') {stop('quit')}#
  }#
#
  height_above <- function(x, y) {#
    if (y == 1) {update(paste('Finding free space',round(x/ncol(maze_grid)*100),'%'))}#
    pos <- tail(which(maze_grid[1:y, x] == 1), 1)[1]#
    if (is.na(pos)) {return(y)}#
    return(y - pos)#
  }#
#
  height_grid <- matrix(mapply(height_above, col(maze_grid), row(maze_grid)), nrow=nrow(maze_grid))#
#
  max_area <- function(x, y) {#
    if (y == 1) {update(paste('Calculating areas',round(x/ncol(maze_grid)*100),'%'))}#
    width <- 1#
    height <- height_grid[y, x]#
    max_width <- 0#
    max_height <- 0#
    while (height >= 3 && x - (width-1) >= 1) {#
      if (height_grid[y, x-(width-1)] < height) {#
        height <- height_grid[y, x-(width-1)]#
      }#
      if (width*height > max_width*max_height && width >= 3 && height >= 3) {#
        max_width <- width#
        max_height <- height#
      }#
      width <- width + 1#
    }#
    return(paste(max_width, max_height, sep='-'))#
  }#
#
  area_grid <- matrix(mapply(max_area, col(maze_grid), row(maze_grid)), nrow=nrow(maze_grid))#
#
  create_vector <- function(x, y) {#
    data <- as.integer(strsplit(area_grid[y, x], '-')[[1]])#
    if (data[1]*data[2] > 0) {#
      return(paste(x, y, data[1], data[2], sep='-'))#
    }#
  }#
#
  area_vector <- mapply(create_vector, col(maze_grid), row(maze_grid))#
  area_vector <- merge_sort(area_vector, TRUE)#
#
  expand_area <- function(data, grid) {#
    x <- data[1]#
    y <- data[2]#
    width <- data[3]#
    height <- data[4]#
    row_clear = FALSE#
    col_clear = FALSE#
#
    while (width >= 3 && height >= 3 && !row_clear && !col_clear) {#
      if (!row_clear) {#
        if (all(grid[y, (x-(width-1)):x] == 0)) {row_clear = TRUE}#
        else {width <- width - 1}#
      }#
      if (!col_clear) {#
        if (all(grid[(y-(height-1)):y, x] == 0)) {col_clear = TRUE}#
        else {height <- height - 1}#
      }#
    }#
    if (width >= 3 && height >= 3) {#
      grid[(y-(height-1)), (x-(width-1)):x] <- 1#
      grid[y, (x-(width-1)):x] <- 1#
      grid[(y-(height-1)+1):(y-1), x-(width-1)] <- 1#
      grid[(y-(height-1)+1):(y-1), x] <- 1#
      grid[(y-(height-1)+1):(y-1), (x-(width-1)+1):(x-1)] <- 2#
    }#
    return(grid)#
  }#
#
  c <- 1#
  for (row in area_vector) {#
    update(paste('Finding rectangles',round(c/length(area_vector)*100),'%'))#
    area_data <- as.integer(strsplit(row, '-')[[1]])#
    rect_grid <- expand_area(area_data, rect_grid)#
    c += 1#
  }#
  return(rect_grid)#
}
library("data.table")#
source('merge.r')#
create_rect_grid <- function(maze_grid, quit_file, update_file) {#
  rect_grid <- matrix(0, nrow=nrow(maze_grid), ncol=ncol(maze_grid))#
#
  update <- function(text) {#
    check_quit()#
    f <- file(update_file)#
    writeLines(c(text), f)#
    close(f)#
  }#
#
  check_quit <- function() {#
    status <- readChar(quit_file, file.info(quit_file)$size)#
    if (status == 'q') {stop('quit')}#
  }#
#
  height_above <- function(x, y) {#
    if (y == 1) {update(paste('Finding free space',round(x/ncol(maze_grid)*100),'%'))}#
    pos <- tail(which(maze_grid[1:y, x] == 1), 1)[1]#
    if (is.na(pos)) {return(y)}#
    return(y - pos)#
  }#
#
  height_grid <- matrix(mapply(height_above, col(maze_grid), row(maze_grid)), nrow=nrow(maze_grid))#
#
  max_area <- function(x, y) {#
    if (y == 1) {update(paste('Calculating areas',round(x/ncol(maze_grid)*100),'%'))}#
    width <- 1#
    height <- height_grid[y, x]#
    max_width <- 0#
    max_height <- 0#
    while (height >= 3 && x - (width-1) >= 1) {#
      if (height_grid[y, x-(width-1)] < height) {#
        height <- height_grid[y, x-(width-1)]#
      }#
      if (width*height > max_width*max_height && width >= 3 && height >= 3) {#
        max_width <- width#
        max_height <- height#
      }#
      width <- width + 1#
    }#
    return(paste(max_width, max_height, sep='-'))#
  }#
#
  area_grid <- matrix(mapply(max_area, col(maze_grid), row(maze_grid)), nrow=nrow(maze_grid))#
#
  create_vector <- function(x, y) {#
    data <- as.integer(strsplit(area_grid[y, x], '-')[[1]])#
    if (data[1]*data[2] > 0) {#
      return(paste(x, y, data[1], data[2], sep='-'))#
    }#
  }#
#
  area_vector <- mapply(create_vector, col(maze_grid), row(maze_grid))#
  area_vector <- merge_sort(area_vector, TRUE)#
#
  expand_area <- function(data, grid) {#
    x <- data[1]#
    y <- data[2]#
    width <- data[3]#
    height <- data[4]#
    row_clear = FALSE#
    col_clear = FALSE#
#
    while (width >= 3 && height >= 3 && !row_clear && !col_clear) {#
      if (!row_clear) {#
        if (all(grid[y, (x-(width-1)):x] == 0)) {row_clear = TRUE}#
        else {width <- width - 1}#
      }#
      if (!col_clear) {#
        if (all(grid[(y-(height-1)):y, x] == 0)) {col_clear = TRUE}#
        else {height <- height - 1}#
      }#
    }#
    if (width >= 3 && height >= 3) {#
      grid[(y-(height-1)), (x-(width-1)):x] <- 1#
      grid[y, (x-(width-1)):x] <- 1#
      grid[(y-(height-1)+1):(y-1), x-(width-1)] <- 1#
      grid[(y-(height-1)+1):(y-1), x] <- 1#
      grid[(y-(height-1)+1):(y-1), (x-(width-1)+1):(x-1)] <- 2#
    }#
    return(grid)#
  }#
#
  c <- 1#
  for (row in area_vector) {#
    update(paste('Finding rectangles',round(c/length(area_vector)*100),'%'))#
    area_data <- as.integer(strsplit(row, '-')[[1]])#
    rect_grid <- expand_area(area_data, rect_grid)#
    c <- c + 1#
  }#
  return(rect_grid)#
}
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
RECTILINEAR <- FALSE#
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #R INDEXING AND X BEFORE Y#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)                      #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  central_dif_h <- merge_sort(ifelse(edges_up > 0, edges_up, 0), QUIT_FILE, UPDATE_FILE)#
  if (central_dif_h == 'quit') {stop('quit')}#
  central_dif_v <- merge_sort(ifelse(edges_left > 0, edges_left, 0), QUIT_FILE, UPDATE_FILE)#
  if (central_dif_v == 'quit') {stop('quit')}#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])), QUIT_FILE, UPDATE_FILE)#
  if (walls_horizontal == 'quit') {stop('quit')}#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])), QUIT_FILE, UPDATE_FILE)#
  if (walls_vertical == 'quit') {stop('quit')}#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {return(geterrmessage())}#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
GREYSCALE_GRID <- data.matrix(fread(GREYSCALE_FILE))#
QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
RECTILINEAR <- FALSE#
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #R INDEXING AND X BEFORE Y#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)                      #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  central_dif_h <- merge_sort(ifelse(edges_up > 0, edges_up, 0), QUIT_FILE, UPDATE_FILE)#
  if (central_dif_h == 'quit') {stop('quit')}#
  central_dif_v <- merge_sort(ifelse(edges_left > 0, edges_left, 0), QUIT_FILE, UPDATE_FILE)#
  if (central_dif_v == 'quit') {stop('quit')}#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])), QUIT_FILE, UPDATE_FILE)#
  if (walls_horizontal == 'quit') {stop('quit')}#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])), QUIT_FILE, UPDATE_FILE)#
  if (walls_vertical == 'quit') {stop('quit')}#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {return(geterrmessage())}#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
GREYSCALE_GRID <- data.matrix(fread(GREYSCALE_FILE))#
QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
RECTILINEAR <- FALSE#
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #R INDEXING AND X BEFORE Y#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)                      #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  central_dif_h <- merge_sort(ifelse(edges_up > 0, edges_up, 0), QUIT_FILE, UPDATE_FILE)#
  if (central_dif_h == 'quit') {stop('quit')}#
  central_dif_v <- merge_sort(ifelse(edges_left > 0, edges_left, 0), QUIT_FILE, UPDATE_FILE)#
  if (central_dif_v == 'quit') {stop('quit')}#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])), QUIT_FILE, UPDATE_FILE)#
  if (walls_horizontal == 'quit') {stop('quit')}#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])), QUIT_FILE, UPDATE_FILE)#
  if (walls_vertical == 'quit') {stop('quit')}#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
#
main()#
output <- tryCatch(#
  {main()},#
  error=function(cond) {return(geterrmessage())}#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
#GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
#GREYSCALE_GRID <- data.matrix(fread(GREYSCALE_FILE))#
#QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
#UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
#RECTILINEAR <- FALSE#
#source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #R INDEXING AND X BEFORE Y#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)                      #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  print('0')#
  central_dif_h <- merge_sort(ifelse(edges_up > 0, edges_up, 0), QUIT_FILE, UPDATE_FILE, FALSE)#
  if (central_dif_h == 'quit') {stop('quit')}#
  print('1')#
  central_dif_v <- merge_sort(ifelse(edges_left > 0, edges_left, 0), QUIT_FILE, UPDATE_FILE, FALSE)#
  if (central_dif_v == 'quit') {stop('quit')}#
  print('2')#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])), QUIT_FILE, UPDATE_FILE, FALSE)#
  if (walls_horizontal == 'quit') {stop('quit')}#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])), QUIT_FILE, UPDATE_FILE, FALSE)#
  if (walls_vertical == 'quit') {stop('quit')}#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
#
#main()#
output <- tryCatch(#
  {main()},#
  error=function(cond) {return(geterrmessage())}#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
GREYSCALE_GRID <- data.matrix(fread(GREYSCALE_FILE))#
QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
RECTILINEAR <- TRUE#
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #R INDEXING AND X BEFORE Y#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)                      #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  print('0')#
  central_dif_h <- merge_sort(ifelse(edges_up > 0, edges_up, 0), QUIT_FILE, UPDATE_FILE, FALSE)#
  if (central_dif_h == 'quit') {stop('quit')}#
  print('1')#
  central_dif_v <- merge_sort(ifelse(edges_left > 0, edges_left, 0), QUIT_FILE, UPDATE_FILE, FALSE)#
  if (central_dif_v == 'quit') {stop('quit')}#
  print('2')#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])), QUIT_FILE, UPDATE_FILE, FALSE)#
  if (walls_horizontal == 'quit') {stop('quit')}#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])), QUIT_FILE, UPDATE_FILE, FALSE)#
  if (walls_vertical == 'quit') {stop('quit')}#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
#
#main()#
output <- tryCatch(#
  {main()},#
  error=function(cond) {return(geterrmessage())}#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
GREYSCALE_GRID <- data.matrix(fread(GREYSCALE_FILE))#
QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
RECTILINEAR <- TRUE#
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #R INDEXING AND X BEFORE Y#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)                      #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  print('0')#
  central_dif_h <- merge_sort(ifelse(edges_up > 0, edges_up, 0), QUIT_FILE, UPDATE_FILE, FALSE)#
  if (central_dif_h == 'quit') {stop('quit')}#
  print('1')#
  central_dif_v <- merge_sort(ifelse(edges_left > 0, edges_left, 0), QUIT_FILE, UPDATE_FILE, FALSE)#
  if (central_dif_v == 'quit') {stop('quit')}#
  print('2')#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])), QUIT_FILE, UPDATE_FILE, FALSE)#
  if (walls_horizontal == 'quit') {stop('quit')}#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])), QUIT_FILE, UPDATE_FILE, FALSE)#
  if (walls_vertical == 'quit') {stop('quit')}#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
#
main()#
output <- tryCatch(#
  {main()},#
  error=function(cond) {return(geterrmessage())}#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
GREYSCALE_GRID <- data.matrix(fread(GREYSCALE_FILE))#
QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
RECTILINEAR <- TRUE#
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #R INDEXING AND X BEFORE Y#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)                      #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  central_dif_h <- merge_sort(ifelse(edges_up > 0, edges_up, 0))#
  if (central_dif_h == 'quit') {stop('quit')}#
  central_dif_v <- merge_sort(ifelse(edges_left > 0, edges_left, 0))#
  if (central_dif_v == 'quit') {stop('quit')}#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])))#
  if (walls_horizontal == 'quit') {stop('quit')}#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
  if (walls_vertical == 'quit') {stop('quit')}#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
#
main()#
output <- tryCatch(#
  {main()},#
  error=function(cond) {return(geterrmessage())}#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
GREYSCALE_GRID <- data.matrix(fread(GREYSCALE_FILE))#
QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
RECTILINEAR <- TRUE#
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #R INDEXING AND X BEFORE Y#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)                      #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  central_dif_h <- merge_sort(ifelse(edges_up > 0, edges_up, 0))#
  if (central_dif_h == 'quit') {stop('quit')}#
  print(central_dif_h)#
  central_dif_v <- merge_sort(ifelse(edges_left > 0, edges_left, 0))#
  if (central_dif_v == 'quit') {stop('quit')}#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])))#
  if (walls_horizontal == 'quit') {stop('quit')}#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
  if (walls_vertical == 'quit') {stop('quit')}#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
#
main()#
output <- tryCatch(#
  {main()},#
  error=function(cond) {return(geterrmessage())}#
)#
cat(output)
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
WALL_FILE <- 'wall.csv'#
MAZE_FILE <- 'maze.csv'#
GREYSCALE_FILE <- "/Users/danarmstrong/Desktop/Coursework/greyscale.csv"#
QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
RECTILINEAR <- FALSE#
source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #R INDEXING AND X BEFORE Y#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)                      #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  central_dif_h <- merge_sort(ifelse(edges_up > 0, edges_up, 0))#
  central_dif_v <- merge_sort(ifelse(edges_left > 0, edges_left, 0))#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])))#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
lol x = if x == 3 then x else x+1#
lol 8
library("data.table")#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
WALL_FILE <- 'walls.csv'#
MAZE_FILE <- 'maze.csv'#
#GREYSCALE_GRID <- data.matrix(fread("/Users/danarmstrong/Desktop/Coursework/greyscale.csv"))#
#QUIT_FILE <- "/Users/danarmstrong/Desktop/Coursework/quit.txt"#
#UPDATE_FILE <- "/Users/danarmstrong/Desktop/Coursework/update.txt"#
#RECTILINEAR <- FALSE#
#source('/Users/danarmstrong/Desktop/Coursework/merge.r')#
#
main <- function() {#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #R INDEXING AND X BEFORE Y#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)                                  #CALCULATE FOREGROUND & BACKGROUND WEIGHTS & MEANS#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))                      #VECTOR OF ALL T-VALUES WITH MAXIMUM CLASS VARIANCE#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE IF MULTIPLE MAXIMUMS FOUND#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)                      #USE OTSU'S METHOD TO CALCULATE APPROPRIATE THRESHOLD#
  update('Creating Binary Grid')#
  threshold_grid <- ifelse(grid > t, 0, 1)                                       #APPLY THRESHOLD TO GRID TO CREATE BINARY GRID#
  return(threshold_grid)                                                         #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)                                                  #GET SIZE OF GRID#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN (H/V)#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQUENCY DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  central_dif_h <- merge_sort(ifelse(edges_up > 0, edges_up, 0))#
  central_dif_v <- merge_sort(ifelse(edges_left > 0, edges_left, 0))#
  central_dif_h <- central_dif_h[1:(length(central_dif_h)-2)] #add functions#
  central_dif_v <- central_dif_v[1:(length(central_dif_v)-2)] #ends removed due to maze boundaries#
#
  histogram_h <- sapply(0:central_dif_h[length(central_dif_h)], function(x) sum(central_dif_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:central_dif_v[length(central_dif_v)], function(x) sum(central_dif_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- walls_left[2:length(walls_left)] - walls_left[1:(length(walls_left)-1)] #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- walls_up[2:length(walls_up)] - walls_up[1:(length(walls_up)-1)]#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)])))#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  threshold_grid[,20] <- 2#
  return(threshold_grid)#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(sum(section)/(length(range_x)*length(range_y))) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
missing_up <- sapply(1:length(cell_heights), add_up)
a 1:10
a <- c(1:10,NA,120)[!is.na(a)]
a
a <- na.omit(c(1:10,NA,120))
a
a[1]
a[102]
a <- matrix(nrow=3, c(0,0,0,1,0,1,0,0,1))
a
mean(a)
update(paste('Sorting vector of length', length(v))
update(paste('Sorting vector of length', length(v)))
a <- 1:10
length(a)
merge_sort <- function(v, string_input=FALSE) {#
  t <- length(v)#
  return(tryCatch(#
    {main_merge_sort(v, string_input)},#
    error=function(cond) {#
      return(v)#
    }#
  ))#
}#
main_merge_sort <- function(v, string_input) {#
#
  if (length(v) > 16) {update(paste('Sorting vector of length', length(v)))}#
  if (length(v) > 1) {#
    m <- ceiling(length(v) / 2)#
    a <- main_merge_sort(v[1:m], string_input)#
    b <- main_merge_sort(v[(m+1):length(v)], string_input)#
    return(merge_vectors(a, b, string_input))#
  }#
  return(v)#
}#
merge_vectors <- function(a, b, string_input) {#
  pointer_a = 1#
  pointer_b = 1#
  range <- length(a)+length(b)#
  merged <- rep(0, range)#
  for (i in 1:range) {#
    if (pointer_a > length(a)) {#
      merged[i] <- b[pointer_b]#
      pointer_b <- pointer_b + 1#
    }#
    else if (pointer_b > length(b)) {#
      merged[i] <- a[pointer_a]#
      pointer_a <- pointer_a + 1#
    }#
    else if (string_input) {#
      a_value <- prod(as.integer(strsplit(a[pointer_a], '-')[[1]][3:4]))#
      b_value <- prod(as.integer(strsplit(b[pointer_b], '-')[[1]][3:4]))#
      if (a_value > b_value) {#
        merged[i] <- a[pointer_a]#
        pointer_a <- pointer_a + 1#
      }#
      else{#
        merged[i] <- b[pointer_b]#
        pointer_b <- pointer_b + 1#
      }#
    }#
    else {#
      if (a[pointer_a] < b[pointer_b]) {#
        merged[i] <- a[pointer_a]#
        pointer_a <- pointer_a + 1#
      }#
      else{#
        merged[i] <- b[pointer_b]#
        pointer_b <- pointer_b + 1#
      }#
    }#
  }#
  return(merged)#
}
CAP <- 1000#
#
hash <- function(a, b, cap) {#
  v <- a*100 + b#
  x <- (a*100 + b) * 0.5 * (sqrt(5) - 1)#
  return (floor(cap * (x %% 1)))#
}#
#
a <- mapply(hash, 1:1000, 1:1000, 100*100)#
print(max(a))#
plot(b)
CAP <- 1000#
#
hash <- function(a, b, cap) {#
  v <- a*100 + b#
  x <- (a*100 + b) * 0.5 * (sqrt(5) - 1)#
  return (floor(cap * (x %% 1)))#
}#
#
a <- mapply(hash, 1:1000, 1:1000, 100*100)#
b <- sapply(0:max(a), function(x) sum(as.numeric(a==x)))#
plot(b)
CAP <- 1000#
#
hash <- function(a, b, cap) {#
  v <- a*100 + b#
  x <- (a*100 + b) * 0.5 * (sqrt(5) - 1)#
  return (floor(cap * (x %% 1)))#
}#
#
a <- mapply(hash, 1:1000, 1:1000, 100*100)#
b <- sapply(0:max(a), function(x) sum(a==x))#
plot(b)
mode(a)
CAP <- 1000#
#
hash <- function(a, b, cap) {#
  v <- a*100 + b#
  x <- (a*100 + b) * 0.5 * (sqrt(5) - 1)#
  return (floor(cap * (x %% 1)))#
}#
#
a <- mapply(hash, 1:1000, 1:1000, 100*100)#
sum(a==0)#
b <- sapply(0:max(a), function(x) sum(a==x))#
plot(b)
CAP <- 1000#
#
hash <- function(a, b, cap) {#
  v <- a*100 + b#
  x <- (a*100 + b) * 0.5 * (sqrt(5) - 1)#
  return (floor(cap * (x %% 1)))#
}#
#
a <- mapply(hash, 1:1000, 1:1000, 100*100)#
sum(a==1)#
b <- sapply(0:max(a), function(x) sum(a==x))#
plot(b)
CAP <- 1000#
#
hash <- function(a, b, cap) {#
  v <- a*100 + b#
  x <- (a*100 + b) * 0.5 * (sqrt(5) - 1)#
  return (floor(cap * (x %% 1)))#
}#
#
a <- mapply(hash, 1:1000, 1:1000, 100*100)#
sum(a==1:100)#
b <- sapply(0:max(a), function(x) sum(a==x))
CAP <- 1000#
#
hash <- function(a, b, cap) {#
  v <- a*100 + b#
  x <- (a*100 + b) * 0.5 * (sqrt(5) - 1)#
  return (floor(cap * (x %% 1)))#
}#
#
a <- mapply(hash, 1:1000, 1:1000, 100*100)#
sum(a==10)#
b <- sapply(0:max(a), function(x) sum(a==x))
CAP <- 1000#
#
hash <- function(a, b, cap) {#
  v <- a*100 + b#
  x <- (a*100 + b) * 0.5 * (sqrt(5) - 1)#
  return (floor(cap * (x %% 1)))#
}#
#
a <- mapply(hash, 1:1000, 1:1000, 100*100)#
which(a==1:10)#
b <- sapply(0:max(a), function(x) sum(a==x))
CAP <- 1000#
#
hash <- function(a, b, cap) {#
  v <- a*100 + b#
  x <- (a*100 + b) * 0.5 * (sqrt(5) - 1)#
  return (floor(cap * (x %% 1)))#
}#
#
a <- mapply(hash, 1:1000, 1:1000, 100*100)#
which(a==100)#
b <- sapply(0:max(a), function(x) sum(a==x))
CAP <- 1000#
#
hash <- function(a, b, cap) {#
  v <- a*100 + b#
  x <- (a*100 + b) * 0.5 * (sqrt(5) - 1)#
  return (floor(cap * (x %% 1)))#
}#
#
a <- mapply(hash, 1:1000, 1:1000, 100*100)#
print(a[1:10])#
b <- sapply(0:max(a), function(x) sum(a==x))
a <- 1:10, 10
a <- c(1:10, 10)
a
sum(a)
CAP <- 1000#
#
hash <- function(a, b, cap) {#
  v <- a*100 + b#
  x <- (a*100 + b) * 0.5 * (sqrt(5) - 1)#
  return (floor(cap * (x %% 1)))#
}#
#
a <- mapply(hash, 1:1000, 1:1000, 100*100)#
print(a[1:10])#
frequency <- function(x) {#
  sum(as.numeric(a==x)) }#
hist <- sapply(0:max(a), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
plot(hist)
CAP <- 1000#
#
hash <- function(a, b, cap) {#
  v <- a*100 + b#
  x <- (a*100 + b) * 0.5 * (sqrt(5) - 1)#
  return (floor(cap * (x %% 1)))#
}#
#
a <- mapply(hash, 1:1000, 1:1000, 100*100)#
print(a[1:10])#
frequency <- function(x) {#
  sum(as.numeric(a==x)) }#
hist <- sapply(0:max(a), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
hist[1:100]
CAP <- 1000#
#
hash <- function(a, b, cap) {#
  v <- a*100 + b#
  x <- (a*100 + b) * 0.5 * (sqrt(5) - 1)#
  return (floor(cap * (x %% 1)))#
}#
#
a <- mapply(hash, 1:1000, 1:1000, 100*100)#
print(a[1:10])#
frequency <- function(x) {#
  sum(as.numeric(a==x)) }#
print(length(a))#
hist <- sapply(0:max(a), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE FREQUENCIES#
hist[1:100]
library("data.table")                                                           #PACKAGES#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]     #GET INPUT FROM PYTHON#
input <- '/Users/danarmstrong/Desktop/Coursework greyscale.csv quit.txt update.txt True False'#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))                                  #SET GLOBAL CONSTANTS#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
INVERTED <- ifelse(input[6] == 'True', TRUE, FALSE)#
WALL_FILE <- 'walls.csv'#
MAZE_FILE <- 'maze.csv'#
main <- function() {                                                            #MAIN FUNCTION GROUPED FOR ERROR CHECKING#
  print(alpha)#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {                                                            #SAVE MAZE GRID IF RECTILINEAR#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #-1 FOR INDEXING BETWEEN R (1) & PYTHON (0)#
                row.names = FALSE, col.names = FALSE,sep = ",")                 #3:2 SO X IS PRINTED BEFORE Y#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))           #AVERAGE DISTANCE BETWEEN WALLS#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))           #AVERAGE WIDTH OF WALLS#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')                                                         #SAVE THRESHOLD GRID IF NON-RECTILINEAR#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {                                                      #EDIT UPDATE FILE#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {                                                      #CHECK TO SEE IF QUITTING#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}                                             #STOP PROGRAM#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR T VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE WITH MAX VARIANCE#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE VALUES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)#
  update('Creating Binary Grid')#
  if (INVERTED) {threshold_grid <- ifelse(grid < t, 0, 1)}                      #IF INVERTED DARK = 0 & LIGHT = 1#
  else {threshold_grid <- ifelse(grid > t, 0, 1)}#
  return(threshold_grid)                                                        #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {                                       #FINDS MAX VALUE IN GIVEN RANGE#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQ DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  edges_h <- merge_sort(ifelse(edges_up[2:] > 0, edges_up, 0))                  #REMOVE NEGATIVE EDGES & 1ST WALL#
  edges_v <- merge_sort(ifelse(edges_left[2:] > 0, edges_left, 0))              #1ST WALL IS ANOMALY AS IS BOUNDARY OF THE MAZE#
#
  histogram_h <- sapply(0:edges_h[length(edges_h)], function(x) sum(edges_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:edges_v[length(edges_v)], function(x) sum(edges_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- diff(walls_left)                                               #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- diff(walls_up)#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]              #FINDS MULPTIPLE MISSING WALLS AT ONCE#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges) #MOST LIKELY TO BE WALL#
      return(positions) }#
    return(NA) }                                                                #RETURN PLACEHOLDER TO BE REMOVED#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)                       #FIND MISSING WALLS#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)]))) #ADD MISSING AND SORT FOR CORRECT ORDER#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(mean(section)) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
library("data.table")                                                           #PACKAGES#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]     #GET INPUT FROM PYTHON#
input <- '/Users/danarmstrong/Desktop/Coursework greyscale.csv quit.txt update.txt True False'#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))                                  #SET GLOBAL CONSTANTS#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
INVERTED <- ifelse(input[6] == 'True', TRUE, FALSE)#
WALL_FILE <- 'walls.csv'#
MAZE_FILE <- 'maze.csv'#
main <- function() {                                                            #MAIN FUNCTION GROUPED FOR ERROR CHECKING#
  print(alpha)#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {                                                            #SAVE MAZE GRID IF RECTILINEAR#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #-1 FOR INDEXING BETWEEN R (1) & PYTHON (0)#
                row.names = FALSE, col.names = FALSE,sep = ",")                 #3:2 SO X IS PRINTED BEFORE Y#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))           #AVERAGE DISTANCE BETWEEN WALLS#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))           #AVERAGE WIDTH OF WALLS#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')                                                         #SAVE THRESHOLD GRID IF NON-RECTILINEAR#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {                                                      #EDIT UPDATE FILE#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {                                                      #CHECK TO SEE IF QUITTING#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}                                             #STOP PROGRAM#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR T VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE WITH MAX VARIANCE#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE VALUES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)#
  update('Creating Binary Grid')#
  if (INVERTED) {threshold_grid <- ifelse(grid < t, 0, 1)}                      #IF INVERTED DARK = 0 & LIGHT = 1#
  else {threshold_grid <- ifelse(grid > t, 0, 1)}#
  return(threshold_grid)                                                        #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {                                       #FINDS MAX VALUE IN GIVEN RANGE#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQ DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  edges_h <- merge_sort(ifelse(edges_up[2:] > 0, edges_up, 0))                  #REMOVE NEGATIVE EDGES & 1ST WALL#
  edges_v <- merge_sort(ifelse(edges_left[2:] > 0, edges_left, 0))              #1ST WALL IS ANOMALY AS IS BOUNDARY OF THE MAZE#
#
  histogram_h <- sapply(0:edges_h[length(edges_h)], function(x) sum(edges_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:edges_v[length(edges_v)], function(x) sum(edges_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- diff(walls_left)                                               #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- diff(walls_up)#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]              #FINDS MULPTIPLE MISSING WALLS AT ONCE#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges) #MOST LIKELY TO BE WALL#
      return(positions) }#
    return(NA) }                                                                #RETURN PLACEHOLDER TO BE REMOVED#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)                       #FIND MISSING WALLS#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)]))) #ADD MISSING AND SORT FOR CORRECT ORDER#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(mean(section)) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
library("data.table")                                                           #PACKAGES#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]     #GET INPUT FROM PYTHON#
input <- strsplit(as.character('/Users/danarmstrong/Desktop/Coursework greyscale.csv quit.txt update.txt True False'))#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))                                  #SET GLOBAL CONSTANTS#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
INVERTED <- ifelse(input[6] == 'True', TRUE, FALSE)#
WALL_FILE <- 'walls.csv'#
MAZE_FILE <- 'maze.csv'#
main <- function() {                                                            #MAIN FUNCTION GROUPED FOR ERROR CHECKING#
  print(alpha)#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {                                                            #SAVE MAZE GRID IF RECTILINEAR#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #-1 FOR INDEXING BETWEEN R (1) & PYTHON (0)#
                row.names = FALSE, col.names = FALSE,sep = ",")                 #3:2 SO X IS PRINTED BEFORE Y#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))           #AVERAGE DISTANCE BETWEEN WALLS#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))           #AVERAGE WIDTH OF WALLS#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')                                                         #SAVE THRESHOLD GRID IF NON-RECTILINEAR#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {                                                      #EDIT UPDATE FILE#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {                                                      #CHECK TO SEE IF QUITTING#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}                                             #STOP PROGRAM#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR T VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE WITH MAX VARIANCE#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE VALUES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)#
  update('Creating Binary Grid')#
  if (INVERTED) {threshold_grid <- ifelse(grid < t, 0, 1)}                      #IF INVERTED DARK = 0 & LIGHT = 1#
  else {threshold_grid <- ifelse(grid > t, 0, 1)}#
  return(threshold_grid)                                                        #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {                                       #FINDS MAX VALUE IN GIVEN RANGE#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQ DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  edges_h <- merge_sort(ifelse(edges_up[2:] > 0, edges_up, 0))                  #REMOVE NEGATIVE EDGES & 1ST WALL#
  edges_v <- merge_sort(ifelse(edges_left[2:] > 0, edges_left, 0))              #1ST WALL IS ANOMALY AS IS BOUNDARY OF THE MAZE#
#
  histogram_h <- sapply(0:edges_h[length(edges_h)], function(x) sum(edges_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:edges_v[length(edges_v)], function(x) sum(edges_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- diff(walls_left)                                               #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- diff(walls_up)#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]              #FINDS MULPTIPLE MISSING WALLS AT ONCE#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges) #MOST LIKELY TO BE WALL#
      return(positions) }#
    return(NA) }                                                                #RETURN PLACEHOLDER TO BE REMOVED#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)                       #FIND MISSING WALLS#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)]))) #ADD MISSING AND SORT FOR CORRECT ORDER#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(mean(section)) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
library("data.table")                                                           #PACKAGES#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]     #GET INPUT FROM PYTHON#
input <- strsplit(as.character('/Users/danarmstrong/Desktop/Coursework greyscale.csv quit.txt update.txt True False', ' '))#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))                                  #SET GLOBAL CONSTANTS#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
INVERTED <- ifelse(input[6] == 'True', TRUE, FALSE)#
WALL_FILE <- 'walls.csv'#
MAZE_FILE <- 'maze.csv'#
main <- function() {                                                            #MAIN FUNCTION GROUPED FOR ERROR CHECKING#
  print(alpha)#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {                                                            #SAVE MAZE GRID IF RECTILINEAR#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #-1 FOR INDEXING BETWEEN R (1) & PYTHON (0)#
                row.names = FALSE, col.names = FALSE,sep = ",")                 #3:2 SO X IS PRINTED BEFORE Y#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))           #AVERAGE DISTANCE BETWEEN WALLS#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))           #AVERAGE WIDTH OF WALLS#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')                                                         #SAVE THRESHOLD GRID IF NON-RECTILINEAR#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {                                                      #EDIT UPDATE FILE#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {                                                      #CHECK TO SEE IF QUITTING#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}                                             #STOP PROGRAM#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR T VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE WITH MAX VARIANCE#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE VALUES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)#
  update('Creating Binary Grid')#
  if (INVERTED) {threshold_grid <- ifelse(grid < t, 0, 1)}                      #IF INVERTED DARK = 0 & LIGHT = 1#
  else {threshold_grid <- ifelse(grid > t, 0, 1)}#
  return(threshold_grid)                                                        #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {                                       #FINDS MAX VALUE IN GIVEN RANGE#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQ DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  edges_h <- merge_sort(ifelse(edges_up[2:] > 0, edges_up, 0))                  #REMOVE NEGATIVE EDGES & 1ST WALL#
  edges_v <- merge_sort(ifelse(edges_left[2:] > 0, edges_left, 0))              #1ST WALL IS ANOMALY AS IS BOUNDARY OF THE MAZE#
#
  histogram_h <- sapply(0:edges_h[length(edges_h)], function(x) sum(edges_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:edges_v[length(edges_v)], function(x) sum(edges_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- diff(walls_left)                                               #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- diff(walls_up)#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]              #FINDS MULPTIPLE MISSING WALLS AT ONCE#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges) #MOST LIKELY TO BE WALL#
      return(positions) }#
    return(NA) }                                                                #RETURN PLACEHOLDER TO BE REMOVED#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)                       #FIND MISSING WALLS#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)]))) #ADD MISSING AND SORT FOR CORRECT ORDER#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(mean(section)) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
library("data.table")                                                           #PACKAGES#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]     #GET INPUT FROM PYTHON#
input <- strsplit(as.character('/Users/danarmstrong/Desktop/Coursework greyscale.csv quit.txt update.txt True False'), ' ')#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))                                  #SET GLOBAL CONSTANTS#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
INVERTED <- ifelse(input[6] == 'True', TRUE, FALSE)#
WALL_FILE <- 'walls.csv'#
MAZE_FILE <- 'maze.csv'#
main <- function() {                                                            #MAIN FUNCTION GROUPED FOR ERROR CHECKING#
  print(alpha)#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {                                                            #SAVE MAZE GRID IF RECTILINEAR#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #-1 FOR INDEXING BETWEEN R (1) & PYTHON (0)#
                row.names = FALSE, col.names = FALSE,sep = ",")                 #3:2 SO X IS PRINTED BEFORE Y#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))           #AVERAGE DISTANCE BETWEEN WALLS#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))           #AVERAGE WIDTH OF WALLS#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')                                                         #SAVE THRESHOLD GRID IF NON-RECTILINEAR#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {                                                      #EDIT UPDATE FILE#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {                                                      #CHECK TO SEE IF QUITTING#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}                                             #STOP PROGRAM#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR T VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE WITH MAX VARIANCE#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE VALUES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)#
  update('Creating Binary Grid')#
  if (INVERTED) {threshold_grid <- ifelse(grid < t, 0, 1)}                      #IF INVERTED DARK = 0 & LIGHT = 1#
  else {threshold_grid <- ifelse(grid > t, 0, 1)}#
  return(threshold_grid)                                                        #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {                                       #FINDS MAX VALUE IN GIVEN RANGE#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQ DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  edges_h <- merge_sort(ifelse(edges_up[2:] > 0, edges_up, 0))                  #REMOVE NEGATIVE EDGES & 1ST WALL#
  edges_v <- merge_sort(ifelse(edges_left[2:] > 0, edges_left, 0))              #1ST WALL IS ANOMALY AS IS BOUNDARY OF THE MAZE#
#
  histogram_h <- sapply(0:edges_h[length(edges_h)], function(x) sum(edges_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:edges_v[length(edges_v)], function(x) sum(edges_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- diff(walls_left)                                               #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- diff(walls_up)#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]              #FINDS MULPTIPLE MISSING WALLS AT ONCE#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges) #MOST LIKELY TO BE WALL#
      return(positions) }#
    return(NA) }                                                                #RETURN PLACEHOLDER TO BE REMOVED#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)                       #FIND MISSING WALLS#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)]))) #ADD MISSING AND SORT FOR CORRECT ORDER#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(mean(section)) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
library("data.table")                                                           #PACKAGES#
input <- strsplit(as.character(commandArgs(trailingOnly = TRUE)), ' ')[[1]]     #GET INPUT FROM PYTHON#
input <- strsplit(as.character('/Users/danarmstrong/Desktop/Coursework greyscale.csv quit.txt update.txt True False'), ' ')[[1]]#
setwd(input[1])#
source('merge.r')#
GREYSCALE_GRID <- data.matrix(fread(input[2]))                                  #SET GLOBAL CONSTANTS#
QUIT_FILE <- input[3]#
UPDATE_FILE <- input[4]#
RECTILINEAR <- ifelse(input[5] == 'True', TRUE, FALSE)#
INVERTED <- ifelse(input[6] == 'True', TRUE, FALSE)#
WALL_FILE <- 'walls.csv'#
MAZE_FILE <- 'maze.csv'#
main <- function() {                                                            #MAIN FUNCTION GROUPED FOR ERROR CHECKING#
  print(alpha)#
  update('Loading Greyscale')#
  threshold_grid <- threshold(GREYSCALE_GRID)#
  if (RECTILINEAR) {                                                            #SAVE MAZE GRID IF RECTILINEAR#
    structure_matrix <- wall_data(threshold_grid)#
    maze_grid <- maze(threshold_grid, structure_matrix)#
    update('Saving Maze')#
    write.table(structure_matrix[,3:2]-1, file = WALL_FILE,                     #-1 FOR INDEXING BETWEEN R (1) & PYTHON (0)#
                row.names = FALSE, col.names = FALSE,sep = ",")                 #3:2 SO X IS PRINTED BEFORE Y#
    write.table(maze_grid, file = MAZE_FILE,#
                row.names = FALSE, col.names = FALSE,sep = ",")#
    cell_size <- mean(c(structure_matrix[1,1],structure_matrix[3,1]))           #AVERAGE DISTANCE BETWEEN WALLS#
    wall_size <- mean(c(structure_matrix[2,1],structure_matrix[4,1]))           #AVERAGE WIDTH OF WALLS#
    return(c(WALL_FILE, MAZE_FILE, cell_size, wall_size))#
  }#
  update('Saving Maze')                                                         #SAVE THRESHOLD GRID IF NON-RECTILINEAR#
  write.table(threshold_grid, file = MAZE_FILE,row.names = FALSE, col.names = FALSE,sep = ",")#
  return(MAZE_FILE)#
}#
update <- function(text) {                                                      #EDIT UPDATE FILE#
  check_quit()#
  f <- file(UPDATE_FILE)#
  writeLines(c(text), f)#
  close(f)#
}#
check_quit <- function() {                                                      #CHECK TO SEE IF QUITTING#
  status <- readChar(QUIT_FILE, file.info(QUIT_FILE)$size)#
  if (status == 'q') {stop('quit')}                                             #STOP PROGRAM#
}#
threshold_value <- function(hist) {                                             #CALCULATE T-VALUE FOR HISTOGRAM USING OTSU'S METHOD#
  weighted_hist <- as.numeric(hist*0:(length(hist)-1))                          #WEIGHTED HIST STORED TO AVOID REPEATED CALCULATION#
  class_variance <- function(t) {                                               #CALCULATE CLASS VARAINCE FOR PARTICULAR T VALUE#
    update(paste('Calculating Threshold',round(t/length(hist)*100),'%'))#
    range_fg <- (t+1):length(hist)                                              #VECTORS OF FOREGROUND & BACKGROUND RANGES#
    range_bg <- 1:t#
    weight_fg <- sum(hist[range_fg])/sum(hist)#
    weight_bg <- sum(hist[range_bg])/sum(hist)#
    mean_fg <- ifelse(sum(hist[range_fg]) > 0, sum(weighted_hist[range_fg])/sum(hist[range_fg]), 0)   #AVOID DIVISION BY ZERO#
    mean_bg <- ifelse(sum(hist[range_bg]) > 0, sum(weighted_hist[range_bg])/sum(hist[range_bg]), 0)#
    return(weight_fg*weight_bg*(mean_bg-mean_fg)^2)                             #RETURN CLASS VARIANCE FOR GIVEN VALUE#
  }#
  class_variances <- sapply(1:(length(hist)-1), class_variance)                 #CALCULATE CLASS VARIANCE FOR ALL POSSIBLE T_VALUES#
  t_values <- which(class_variances==max(class_variances))#
  return(median(t_values))                                                      #RETURN MEDIAN T-VALUE WITH MAX VARIANCE#
}#
threshold <- function(grid) {                                                   #THRESHOLD GREYSCALE GRID USING OTSU'S METHOD#
  frequency <- function(x) {#
    update(paste('Creating Histogram',round(x/max(grid)*100),'%'))#
    sum(as.numeric(grid==x)) }#
  hist <- sapply(0:max(grid), frequency)                                        #CREATE HISTOGRAM OF LUMINANCE VALUES#
  t <- ifelse(length(hist) > 1, threshold_value(hist), -1)#
  update('Creating Binary Grid')#
  if (INVERTED) {threshold_grid <- ifelse(grid < t, 0, 1)}                      #IF INVERTED DARK = 0 & LIGHT = 1#
  else {threshold_grid <- ifelse(grid > t, 0, 1)}#
  return(threshold_grid)                                                        #RETURN BINARY MATRIX#
}#
local_maximum <- function(vector, a, b) {                                       #FINDS MAX VALUE IN GIVEN RANGE#
  range <- vector[a:b]#
  maximum <- round(median(which(range==max(range))))#
  return(a + maximum - 1)#
}#
wall_data <- function(threshold_grid) {                                         #DETERMINES STRUCTURE OF WALLS FROM THRESHOLD GRID#
  update('Calculating Frequencies')#
  rows <- nrow(threshold_grid)#
  cols <- ncol(threshold_grid)#
  frequencies_h <- apply(threshold_grid, 1, sum)                                #CALCULATE FREQUENCY OF 1'S PER ROW/COLUMN#
  frequencies_v <- apply(threshold_grid, 2, sum)#
  update('Finding Edges')#
  edges_up <- c(head(frequencies_h, 1), diff(frequencies_h))                    #FIND FREQ DIFFERENCES BETWEEN NEIGHBOURING ROWS/COLUMNS#
  edges_down <- c(diff(frequencies_h)*(-1), tail(frequencies_h, 1))#
  edges_left <- c(head(frequencies_v, 1), diff(frequencies_v))#
  edges_right <- c(diff(frequencies_v)*(-1), tail(frequencies_v, 1))#
  edges_h <- merge_sort(ifelse(edges_up[2:] > 0, edges_up, 0))                  #REMOVE NEGATIVE EDGES & 1ST WALL#
  edges_v <- merge_sort(ifelse(edges_left[2:] > 0, edges_left, 0))              #1ST WALL IS ANOMALY AS IS BOUNDARY OF THE MAZE#
#
  histogram_h <- sapply(0:edges_h[length(edges_h)], function(x) sum(edges_h==x)) #CALCULATE THRESHOLD VALUE USING OTSU'S METHOD#
  histogram_v <- sapply(0:edges_v[length(edges_v)], function(x) sum(edges_v==x))#
  threshold_h <- threshold_value(histogram_h)                                   #ROWS/COLUMNS WITH DIFFERENCES ABOVE THRESHOLD ARE WALLS#
  threshold_v <- threshold_value(histogram_v)#
#
  update('Finding Walls')#
  walls_up <- which(edges_up>threshold_h)                                 #POSITION OF HORIZONTAL/VERTICAL WALLS IN GRID#
  walls_down <- which(edges_down>threshold_h)                             #UP IS TOP SIDE OF WALL & DOWN IS BOTTOM SIDE#
  walls_left <- which(edges_left>threshold_v)#
  walls_right <- which(edges_right>threshold_v)#
  wall_widths <- sapply(walls_left, function(x) walls_right[walls_right>=x][1] - x) #AVERAGE DISTANCE BETWEEN SIDES OF WALL#
  wall_heights <- sapply(walls_up, function(x) walls_down[walls_down>=x][1] - x)#
  wall_width <- mean(wall_widths[wall_widths<=median(wall_widths)]) + 1         #ADD 1 DUE TO UNDERCALCULATION OF SIZE#
  wall_height <- mean(wall_heights[wall_heights<=median(wall_heights)]) + 1#
#
  update('Finding Cells')#
  cell_widths <- diff(walls_left)                                               #GET DISTANCE BETWEEN NEIGHBOURING WALLS#
  cell_heights <- diff(walls_up)#
  cell_width <- mean(cell_widths[cell_widths<=median(cell_widths)])             #CALCULATE AVERAGE DISTANCE BETWEEN WALLS#
  cell_height <- mean(cell_heights[cell_heights<=median(cell_heights)])#
#
  add_left <- function(i) {#
    missing_amount <- round(cell_widths[i] / cell_width) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_width+walls_left[i]              #FINDS MULPTIPLE MISSING WALLS AT ONCE#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_width))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_width))#
      positions <- mapply(function(a, b) local_maximum(edges_left, a, b), min_ranges, max_ranges) #MOST LIKELY TO BE WALL#
      return(positions) }#
    return(NA) }                                                                #RETURN PLACEHOLDER TO BE REMOVED#
#
  add_up <- function(i) {#
    missing_amount <- round(cell_heights[i] / cell_height) - 1#
    if (missing_amount > 0) {#
      mid_estimates <- (1:missing_amount)*cell_height+walls_up[i]#
      min_ranges <- sapply(mid_estimates, function(x) round(x-0.5*cell_height))#
      max_ranges <- sapply(mid_estimates, function(x) round(x+0.5*cell_height))#
      positions <- mapply(function(a, b) local_maximum(edges_up, a, b), min_ranges, max_ranges)#
      return(positions) }#
    return(NA) }#
#
  update('Locating Missing Walls')#
  missing_left <- sapply(1:length(cell_widths), add_left)                       #FIND MISSING WALLS#
  missing_up <- sapply(1:length(cell_heights), add_up)#
  walls_horizontal <- merge_sort(unlist(c(walls_up, missing_up[!is.na(missing_up)]))) #ADD MISSING AND SORT FOR CORRECT ORDER#
  walls_vertical <- merge_sort(unlist(c(walls_left, missing_left[!is.na(missing_left)])))#
#
  cell_data <- c(cell_width, wall_width, cell_height, wall_height)#
  range <- 1:max(length(cell_data),length(walls_horizontal),length(walls_vertical))#
  return(matrix(c(cell_data[range],walls_horizontal[range],walls_vertical[range]),ncol=3))#
}#
maze <- function(threshold_grid, structure_matrix) {                            #CREATE MAZE GRID FROM THRESHOLD GRID#
  update('Calculating Structure')#
  wall_width <- structure_matrix[2,1]#
  wall_height <- structure_matrix[4,1]#
  walls_horizontal <- structure_matrix[,2][!is.na(structure_matrix[,2])]#
  walls_vertical <- structure_matrix[,3][!is.na(structure_matrix[,3])]#
  dimensions_x <- length(walls_vertical)-1#
  dimensions_y <- length(walls_horizontal)-1#
#
  section_density <- function(x, y) {#
    if (y == 1) {update(paste('Building Maze',round(x/(dimensions_x*2+1)*100),'%'))}#
    if (x %% 2 == 0) {#
      range_x <- (walls_vertical[x/2]+wall_width):(walls_vertical[x/2+1]-1) }#
    else {#
      range_x <- walls_vertical[(x+1)/2]:(walls_vertical[(x+1)/2]+wall_width-1) }#
    if (y %% 2 == 0) {#
      range_y <- (walls_horizontal[y/2]+wall_height):(walls_horizontal[y/2+1]-1) }#
    else {#
      range_y <- walls_horizontal[(y+1)/2]:(walls_horizontal[(y+1)/2]+wall_height-1) }#
    section <- threshold_grid[range_y,range_x]#
    return(mean(section)) }#
#
  empty_grid <- matrix(0, nrow=dimensions_y*2+1, ncol=dimensions_x*2+1)#
  density_grid <- matrix(mapply(section_density, col(empty_grid), row(empty_grid)), nrow=nrow(empty_grid))#
  maze_grid <- ifelse(density_grid > 0.25, 1, 0)#
  return(maze_grid)#
}#
#
output <- tryCatch(#
  {main()},#
  error=function(cond) {#
    return(geterrmessage())#
  }#
)#
cat(output)
